{"name_of_backup": "20260104161653_GameFolder", "changes": [{"path": "GameFolder/projectiles/RicochetProjectiles.py", "diff": "--- a/GameFolder/projectiles/RicochetProjectiles.py\n+++ b/GameFolder/projectiles/RicochetProjectiles.py\n@@ -0,0 +1,104 @@\n+import pygame\n+import math\n+import random\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class DiscProjectile(Projectile):\n+    def __init__(self, x: float, y: float, direction: list[float], speed: float, damage: float, owner_id: str):\n+        super().__init__(x, y, direction, speed, damage, owner_id, width=20, height=20)\n+        self.bounces = 0\n+        self.max_bounces = 4\n+        self.damage_multiplier = 1.2\n+        self.speed_multiplier = 1.1\n+        self.rotation = 0.0\n+        self.trail = [] # List of (x, y) coordinates\n+        self.max_trail_len = 10\n+        self.color = (0, 255, 255) # Neon Cyan\n+\n+    def update(self, delta_time: float):\n+        # Store previous position for trail\n+        self.trail.insert(0, (self.location[0], self.location[1]))\n+        if len(self.trail) > self.max_trail_len:\n+            self.trail.pop()\n+\n+        # Update location using base logic\n+        super().update(delta_time)\n+\n+        # Spin rotation (degrees)\n+        spin_speed = 720 # degrees per second\n+        self.rotation = (self.rotation + spin_speed * delta_time) % 360\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+\n+        # Draw trail\n+        for i, pos in enumerate(self.trail):\n+            alpha = int(255 * (1 - (i / self.max_trail_len)))\n+            trail_color = (0, 200, 255, alpha)\n+            # Pygame doesn't support alpha in draw.ellipse directly easily without surface, \n+            # but we can simulate fading colors\n+            r, g, b = 0, 100 + int(100 * (1 - i/self.max_trail_len)), 255\n+            py_y = arena_height - pos[1] - self.height\n+            trail_rect = pygame.Rect(pos[0], py_y, self.width, self.height)\n+            pygame.draw.ellipse(screen, (r, g, b), trail_rect, 1)\n+\n+        # Draw spinning disc\n+        py_y = arena_height - self.location[1] - self.height\n+        center_x = self.location[0] + self.width / 2\n+        center_y = py_y + self.height / 2\n+        \n+        # Glow\n+        pygame.draw.ellipse(screen, (0, 100, 100), (self.location[0]-2, py_y-2, self.width+4, self.height+4), 2)\n+        \n+        # Main Disc\n+        pygame.draw.ellipse(screen, self.color, (self.location[0], py_y, self.width, self.height))\n+        \n+        # Spinning line detail\n+        rad = math.radians(self.rotation)\n+        end_x = center_x + math.cos(rad) * (self.width / 2)\n+        end_y = center_y + math.sin(rad) * (self.height / 2)\n+        pygame.draw.line(screen, (255, 255, 255), (center_x, center_y), (end_x, end_y), 2)\n+\n+class DiscShard(Projectile):\n+    def __init__(self, x: float, y: float, direction: list[float], speed: float, damage: float, owner_id: str):\n+        # Small, fast shards\n+        super().__init__(x, y, direction, speed, damage, owner_id, width=6, height=6)\n+        self.color = (255, 100, 0) # Orange-ish neon\n+        self.distance_traveled = 0.0\n+        self.max_distance = 150.0 # Expires after short distance\n+        self.lifetime = 1.0 # Or 1 second\n+        self.timer = 0.0\n+\n+    def update(self, delta_time: float):\n+        prev_x, prev_y = self.location[0], self.location[1]\n+        super().update(delta_time)\n+        \n+        # Calculate distance traveled\n+        dist = math.hypot(self.location[0] - prev_x, self.location[1] - prev_y)\n+        self.distance_traveled += dist\n+        \n+        self.timer += delta_time\n+        \n+        if self.distance_traveled >= self.max_distance or self.timer >= self.lifetime:\n+            self.active = False\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        \n+        # Draw shard as a small line/triangle pointing in direction\n+        center_x = self.location[0] + self.width / 2\n+        center_y = py_y + self.height / 2\n+        \n+        length = 8\n+        end_x = center_x - self.direction[0] * length\n+        end_y = center_y + self.direction[1] * length # + because screen Y is inverted\n+        \n+        pygame.draw.line(screen, self.color, (center_x, center_y), (end_x, end_y), 2)\n+        \n+        # Small head\n+        head_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        pygame.draw.rect(screen, (255, 255, 255), head_rect)"}, {"path": "GameFolder/weapons/RicochetLauncher.py", "diff": "--- a/GameFolder/weapons/RicochetLauncher.py\n+++ b/GameFolder/weapons/RicochetLauncher.py\n@@ -0,0 +1,93 @@\n+import pygame\n+import math\n+import time\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.RicochetProjectiles import DiscProjectile\n+\n+class RicochetLauncher(Weapon):\n+    def __init__(self, location: [float, float] = None):\n+        # High damage, medium cooldown, fast projectiles\n+        super().__init__(\n+            name=\"Ricochet Disc Launcher\",\n+            damage=25.0,\n+            cooldown=0.6,\n+            projectile_speed=25.0,\n+            location=location\n+        )\n+        self.width = 45\n+        self.height = 20\n+        self.color = (57, 255, 20)  # Neon Green\n+        self.accent_color = (0, 255, 255)  # Cyan\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        if not self.can_shoot():\n+            return []\n+\n+        self.last_shot_time = time.time()\n+\n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+\n+        if dist == 0:\n+            direction = [1, 0]\n+        else:\n+            direction = [dx / dist, dy / dist]\n+\n+        # Spawn the DiscProjectile\n+        projectile = DiscProjectile(\n+            owner_x, \n+            owner_y, \n+            direction, \n+            self.projectile_speed, \n+            self.damage, \n+            owner_id\n+        )\n+        return [projectile]\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"\n+        Override to show a futuristic neon weapon with a disc chamber.\n+        \"\"\"\n+        if self.is_equipped:\n+            return\n+\n+        # Convert y-up to pygame y-down\n+        py_y = arena_height - self.location[1] - self.height\n+        weapon_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+\n+        # Glow effect\n+        glow_rect = weapon_rect.inflate(6, 6)\n+        pygame.draw.rect(screen, (0, 100, 0), glow_rect, border_radius=5)\n+\n+        # Weapon body (Futuristic Sleek Design)\n+        pygame.draw.rect(screen, (30, 30, 30), weapon_rect, border_radius=3)\n+        \n+        # Neon Green Rails\n+        rail_top = pygame.Rect(self.location[0], py_y, self.width, 4)\n+        rail_bottom = pygame.Rect(self.location[0], py_y + self.height - 4, self.width, 4)\n+        pygame.draw.rect(screen, self.color, rail_top)\n+        pygame.draw.rect(screen, self.color, rail_bottom)\n+\n+        # Cyan Disc Chamber (the \"heart\" of the launcher)\n+        chamber_rect = pygame.Rect(self.location[0] + 5, py_y + 4, 15, 12)\n+        pygame.draw.ellipse(screen, self.accent_color, chamber_rect)\n+        pygame.draw.ellipse(screen, (255, 255, 255), chamber_rect, 1) # Internal highlight\n+\n+        # White Border\n+        pygame.draw.rect(screen, (255, 255, 255), weapon_rect, 2, border_radius=3)\n+\n+        # Labeling\n+        font = pygame.font.Font(None, 22)\n+        text = font.render(\"DISC\", True, self.accent_color)\n+        text_rect = text.get_rect(center=(self.location[0] + self.width/2 + 10, py_y + self.height/2))\n+        \n+        # Small BG for text\n+        bg_rect = text_rect.inflate(4, 2)\n+        pygame.draw.rect(screen, (0, 0, 0), bg_rect)\n+        screen.blit(text, text_rect)\n+\n+        # Name Tag above weapon\n+        name_font = pygame.font.Font(None, 20)\n+        name_text = name_font.render(self.name, True, (255, 255, 255))\n+        screen.blit(name_text, (self.location[0], py_y - 20))"}, {"path": "GameFolder/setup.py", "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,7 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.RicochetLauncher import RicochetLauncher\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +45,9 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"Ricochet Launcher\", RicochetLauncher)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(RicochetLauncher([600, 400]))\n     \n     return arena"}, {"path": "GameFolder/arenas/GAME_arena.py", "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,8 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.RicochetLauncher import RicochetLauncher\n+from GameFolder.projectiles.RicochetProjectiles import DiscProjectile, DiscShard\n import pygame\n import random\n import math\n@@ -26,6 +28,7 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"RicochetLauncher\", RicochetLauncher)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +50,7 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, DiscProjectile, DiscShard)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -105,7 +108,7 @@\n \n                 if proj.is_stationary:\n                     # Pull platforms (skip floor at index 0)\n-                    for plat in self.platforms[1:]:\n+                    for plat in self.platforms:\n                         bh_screen_x = proj.location[0]\n                         bh_screen_y = self.height - proj.location[1]\n                         \n@@ -170,7 +173,7 @@\n                             weapon.location[0] += pull_dir * proj.pull_strength\n                             weapon.location[1] += proj.pull_strength * 0.8\n \n-                for plat in self.platforms[1:]:\n+                for plat in self.platforms:\n                     # Platform world-y (bottom)\n                     plat_world_y = self.height - plat.rect.bottom\n                     h_diff = plat_world_y - proj.location[1]\n@@ -226,18 +229,118 @@\n                     char_w = char.width * char.scale_ratio\n                     if char.location[0] < beam_x_max and char.location[0] + char_w > beam_x_min:\n                         char.take_damage(proj.damage * delta_time)\n-            \n-            # Put persistent projectile back into active list\n-            if proj.active:\n+\n+            elif isinstance(proj, DiscProjectile):\n+                # Screen Boundary Bouncing\n+                bounced = False\n+                if proj.location[0] < 0 or proj.location[0] + proj.width > self.width:\n+                    proj.direction[0] *= -1\n+                    proj.location[0] = max(0, min(proj.location[0], self.width - proj.width))\n+                    bounced = True\n+                if proj.location[1] < 0 or proj.location[1] + proj.height > self.height:\n+                    proj.direction[1] *= -1\n+                    proj.location[1] = max(0, min(proj.location[1], self.height - proj.height))\n+                    bounced = True\n+\n+                if bounced:\n+                    proj.bounces += 1\n+                    proj.damage *= proj.damage_multiplier\n+                    proj.speed *= proj.speed_multiplier\n+\n+                # Platform Bouncing\n+                p_py_x = proj.location[0]\n+                p_py_y = self.height - proj.location[1] - proj.height\n+                p_py_rect = pygame.Rect(p_py_x, p_py_y, proj.width, proj.height)\n+                \n+                for plat in self.platforms:\n+                    if p_py_rect.colliderect(plat.rect):\n+                        # Collision side detection\n+                        overlap_left = p_py_rect.right - plat.rect.left\n+                        overlap_right = plat.rect.right - p_py_rect.left\n+                        overlap_top = p_py_rect.bottom - plat.rect.top\n+                        overlap_bottom = plat.rect.bottom - p_py_rect.top\n+\n+                        min_overlap = min(overlap_left, overlap_right, overlap_top, overlap_bottom)\n+\n+                        if min_overlap == overlap_left:\n+                            proj.direction[0] = -abs(proj.direction[0])\n+                            proj.location[0] = plat.rect.left - proj.width\n+                        elif min_overlap == overlap_right:\n+                            proj.direction[0] = abs(proj.direction[0])\n+                            proj.location[0] = plat.rect.right\n+                        elif min_overlap == overlap_top:\n+                            proj.direction[1] = abs(proj.direction[1]) # Screen-Y down is World-Y up\n+                            proj.location[1] = self.height - plat.rect.top\n+                        elif min_overlap == overlap_bottom:\n+                            proj.direction[1] = -abs(proj.direction[1])\n+                            proj.location[1] = self.height - plat.rect.bottom - proj.height\n+\n+                        proj.bounces += 1\n+                        proj.damage *= proj.damage_multiplier\n+                        proj.speed *= proj.speed_multiplier\n+                        break\n+\n+                # Character Collision\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id: continue\n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    if char_rect.colliderect(p_py_rect):\n+                        char.take_damage(proj.damage)\n+                        proj.active = False\n+\n+                # Shard Spawning logic\n+                if proj.bounces >= proj.max_bounces or not proj.active:\n+                    if proj.active: # Only spawn if it reached max bounces (not if destroyed by other means yet)\n+                        for i in range(8):\n+                            angle = math.radians(i * 45)\n+                            shard_dir = [math.cos(angle), math.sin(angle)]\n+                            shard = DiscShard(\n+                                proj.location[0],\n+                                proj.location[1],\n+                                shard_dir,\n+                                proj.speed * 1.5,\n+                                proj.damage * 0.5,\n+                                proj.owner_id\n+                            )\n+                            # Boost shard damage based on disc's final damage\n+                            shard.damage = proj.damage * 0.5\n+                            self.projectiles.append(shard)\n+                        proj.active = False\n+\n+            elif isinstance(proj, DiscShard):\n+                # Shards simply expire or hit characters (standard logic handles character hits)\n+                # Screen Boundary check for shards to keep them in arena\n+                if proj.location[0] + proj.width < 0 or proj.location[0] > self.width or \\\n+                   proj.location[1] < 0 or proj.location[1] > self.height:\n+                    proj.active = False\n+                \n+                # Check for character hits (Shards aren't standard projs in this loop)\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id: continue\n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    \n+                    shard_x = proj.location[0]\n+                    shard_y = self.height - proj.location[1] - proj.height\n+                    shard_rect = pygame.Rect(shard_x, shard_y, proj.width, proj.height)\n+                    if char_rect.colliderect(shard_rect):\n+                        char.take_damage(proj.damage)\n+                        proj.active = False\n+\n+        # Remove off-screen special projectiles (just in case)\n+        for p in self.projectiles[:]:\n+            if (p.location[0] < -500 or p.location[0] > self.width + 500 or \n+                p.location[1] < -500 or p.location[1] > self.height + 500):\n+                if p in self.projectiles:\n+                    self.projectiles.remove(p)\n+\n+        # Put persistent projectile back into active list\n+        for proj in special_projs:\n+            if proj.active and proj not in self.projectiles:\n                 self.projectiles.append(proj)\n-            \n-            # Remove off-screen special projectiles (just in case)\n-            if (proj.location[0] < -200 or proj.location[0] > self.width + 200 or \n-                proj.location[1] < -200 or proj.location[1] > self.height + 200):\n-                if proj in self.projectiles:\n-                    self.projectiles.remove(proj)\n-\n-        for plat in self.platforms[1:]: # Skip floor\n+                    \n+        for plat in self.platforms: \n             if not getattr(plat, 'being_pulled', False):\n                 plat.return_to_origin(delta_time)\n \n"}, {"path": "GameFolder/tests/ricochet_launcher_tests.py", "diff": "--- a/GameFolder/tests/ricochet_launcher_tests.py\n+++ b/GameFolder/tests/ricochet_launcher_tests.py\n@@ -0,0 +1,278 @@\n+\"\"\"\n+Tests for Ricochet Disc Launcher weapon and its associated projectiles.\n+\"\"\"\n+\n+import pytest\n+import pygame\n+import math\n+from GameFolder.weapons.RicochetLauncher import RicochetLauncher\n+from GameFolder.projectiles.RicochetProjectiles import DiscProjectile, DiscShard\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.platforms.GAME_platform import Platform\n+from GameFolder.setup import setup_battle_arena\n+\n+def test_ricochet_launcher_properties():\n+    \"\"\"Verify Ricochet Launcher initial properties.\"\"\"\n+    launcher = RicochetLauncher()\n+    assert launcher.name == \"Ricochet Disc Launcher\"\n+    assert launcher.damage == 25.0\n+    assert launcher.cooldown == 0.6\n+    assert launcher.projectile_speed == 25.0\n+\n+def test_ricochet_launcher_shooting():\n+    \"\"\"Verify Ricochet Launcher spawns a DiscProjectile.\"\"\"\n+    launcher = RicochetLauncher()\n+    launcher.last_shot_time = 0\n+    # Shoot from (100, 100) towards (200, 100) - straight right\n+    projectiles = launcher.shoot(100, 100, 200, 100, \"player1\")\n+    assert len(projectiles) == 1\n+    assert isinstance(projectiles[0], DiscProjectile)\n+    assert projectiles[0].owner_id == \"player1\"\n+    assert projectiles[0].direction == [1.0, 0.0]\n+    assert projectiles[0].speed == 25.0\n+    assert projectiles[0].width == 20\n+    assert projectiles[0].height == 20\n+\n+def test_disc_projectile_initial_state():\n+    \"\"\"Verify DiscProjectile initial state and attributes.\"\"\"\n+    disc = DiscProjectile(100, 100, [1, 0], 25.0, 25.0, \"owner\")\n+    assert disc.bounces == 0\n+    assert disc.max_bounces == 4\n+    assert disc.damage_multiplier == 1.2\n+    assert disc.speed_multiplier == 1.1\n+    assert disc.rotation == 0.0\n+    assert len(disc.trail) == 0\n+\n+def test_disc_projectile_update():\n+    \"\"\"Verify DiscProjectile updates rotation and trail.\"\"\"\n+    disc = DiscProjectile(100, 100, [1, 0], 25.0, 25.0, \"owner\")\n+    initial_pos = list(disc.location)\n+    \n+    dt = 0.016\n+    disc.update(dt)\n+    \n+    # Trail should have one entry (previous position)\n+    assert len(disc.trail) == 1\n+    assert disc.trail[0] == (initial_pos[0], initial_pos[1])\n+    \n+    # Rotation should have increased\n+    # 720 degrees/sec * 0.016 sec = 11.52 degrees\n+    assert disc.rotation == pytest.approx(11.52)\n+    \n+    # Update multiple times to fill trail\n+    for _ in range(20):\n+        disc.update(dt)\n+    \n+    assert len(disc.trail) == disc.max_trail_len\n+\n+def test_disc_shard_behavior():\n+    \"\"\"Verify DiscShard expires after distance/time.\"\"\"\n+    shard = DiscShard(100, 100, [1, 0], 50.0, 10.0, \"owner\")\n+    assert shard.active\n+    \n+    # Update until expiration (max_distance = 150)\n+    # speed = 50.0. In one frame (dt=1/60), it moves by 50 pixels.\n+    # 3 frames should be 150 pixels.\n+    shard.update(1/60)\n+    assert shard.active\n+    shard.update(1/60)\n+    assert shard.active\n+    shard.update(1/60)\n+    assert not shard.active\n+\n+def test_ricochet_wall_bounce():\n+    \"\"\"Verify DiscProjectile bounces off arena boundaries.\"\"\"\n+    arena = Arena(800, 600)\n+    # Width=20, so right edge is at x+20. \n+    # Speed 100 * (1/60) = 1.666 pixels.\n+    # Initial x=779. Right edge is 799.\n+    # Move 1.666 -> right edge becomes 800.666. Hits wall.\n+    disc = DiscProjectile(779, 300, [1, 0], 100.0, 25.0, \"owner\")\n+    arena.projectiles.append(disc)\n+    \n+    initial_damage = disc.damage\n+    \n+    # Update frame\n+    arena.handle_collisions(1/60)\n+    \n+    # Should bounce back (direction[0] *= -1)\n+    assert disc.direction[0] == pytest.approx(-1.0)\n+    # Right edge should be at 800, so location[0] = 800 - 20 = 780\n+    assert disc.location[0] == pytest.approx(780)\n+    assert disc.bounces == 1\n+    assert disc.damage > initial_damage\n+def test_ricochet_platform_bounce():\n+    \"\"\"Verify DiscProjectile bounces off platforms and increases stats.\"\"\"\n+    arena = Arena(800, 600)\n+    # Disc moving down towards a platform\n+    # Platform at y=200 in world coords. Screen-y = 600 - 200 = 400.\n+    # Height = 20. Top is at 400, Bottom at 420 (screen coords).\n+    plat = Platform(100, 400, 200, 20) \n+    arena.platforms.append(plat)\n+    \n+    # Disc at world-y 201, moving down (0, -1)\n+    # height=20. Bottom edge (world-y) is 201.\n+    # Speed 100 * (1/60) = 1.666 pixels.\n+    # New world-y bottom = 201 - 1.666 = 199.333. (Intersects platform top at 200)\n+    disc = DiscProjectile(200, 201, [0, -1], 100.0, 25.0, \"owner\")\n+    arena.projectiles.append(disc)\n+    \n+    initial_damage = disc.damage\n+    initial_speed = disc.speed\n+    \n+    # Move disc into platform\n+    arena.handle_collisions(1/60)\n+    \n+    # After bounce, position should be corrected to the platform surface\n+    \n+    assert disc.bounces == 1\n+    # Direction should be reversed (up)\n+    assert disc.direction[1] == pytest.approx(1.0)\n+    # Stats should increase\n+    assert disc.damage == pytest.approx(initial_damage * disc.damage_multiplier)\n+    assert disc.speed == pytest.approx(initial_speed * disc.speed_multiplier)\n+    # Position should be corrected: world-y 200 (platform top)\n+    assert disc.location[1] == pytest.approx(200)\n+def test_ricochet_shard_spawning():\n+    \"\"\"Verify DiscProjectile spawns shards after max bounces.\"\"\"\n+    arena = Arena(800, 600)\n+    # Reach max bounces (4)\n+    disc = DiscProjectile(400, 300, [1, 0], 25.0, 25.0, \"owner\")\n+    disc.bounces = 4\n+    arena.projectiles.append(disc)\n+    \n+    # Handle collisions to trigger shard spawn\n+    arena.handle_collisions(0.016)\n+    \n+    # Disc should be inactive\n+    assert not disc.active\n+    assert disc not in arena.projectiles\n+    \n+    # Should have spawned 8 shards\n+    shards = [p for p in arena.projectiles if isinstance(p, DiscShard)]\n+    assert len(shards) == 8\n+    \n+    # Check radial pattern\n+    directions = [tuple(s.direction) for s in shards]\n+    # One shard should be moving right (angle 0: cos=1, sin=0)\n+    assert (pytest.approx(1.0), pytest.approx(0.0)) in directions\n+    # One shard should be moving left (angle 180: cos=-1, sin=0)\n+    assert (pytest.approx(-1.0), pytest.approx(0.0)) in directions\n+\n+def test_ricochet_shard_damage():\n+    \"\"\"Verify DiscShards deal damage to characters.\"\"\"\n+    arena = Arena(800, 600)\n+    # Shard at (400, 300) moving right\n+    shard = DiscShard(400, 300, [1, 0], 50.0, 20.0, \"attacker\")\n+    arena.projectiles.append(shard)\n+    \n+    # Character in front of shard\n+    # Char at 410 world-x. Char width is 45.\n+    # Char world-y 280. \n+    victim = Character(\"Victim\", \"\", \"\", [410, 280])\n+    victim.id = \"victim\"\n+    arena.characters.append(victim)\n+    \n+    initial_hp = victim.health\n+    \n+    # Run collision logic\n+    # Shard logic in GAME_arena uses collidepoint on shard center\n+    arena.handle_collisions(0.016)\n+    \n+    # Expected damage: 20 raw - 5 defense = 15.\n+    assert victim.health == initial_hp - 15\n+    assert not shard.active\n+\n+def test_lootpool_registration():\n+    \"\"\"Verify that Ricochet Launcher is in the lootpool.\"\"\"\n+    arena = setup_battle_arena()\n+    assert \"Ricochet Launcher\" in arena.lootpool, \"Ricochet Launcher was not registered in the lootpool\"\n+\n+def test_ricochet_integration_gameplay():\n+    \"\"\"Integration test for full disc lifecycle.\"\"\"\n+    arena = Arena(800, 600)\n+    \n+    # Add characters\n+    attacker = Character(\"Attacker\", \"\", \"\", [100, 100])\n+    attacker.id = \"attacker\"\n+    arena.characters.append(attacker)\n+    \n+    victim = Character(\"Victim\", \"\", \"\", [600, 100])\n+    victim.id = \"victim\"\n+    arena.characters.append(victim)\n+    \n+    # Give weapon\n+    launcher = RicochetLauncher()\n+    attacker.weapon = launcher\n+    attacker.weapon.is_equipped = True\n+    \n+    # Add platform for bouncing\n+    # Platform at x=400, y=500 world coords. (Top of arena)\n+    plat = Platform(300, 100, 200, 20) # Rect at screen-y 100. World-y bottom = 600 - 100 - 20 = 480. Top = 500.\n+    arena.platforms.append(plat)\n+    \n+    # Shoot up at the platform\n+    # attacker at (100, 100). platform at (400, 500).\n+    projectiles = attacker.shoot([400, 500])\n+    arena.projectiles.extend(projectiles)\n+    \n+    disc = projectiles[0]\n+    assert isinstance(disc, DiscProjectile)\n+    \n+    # 1. Reach platform and bounce\n+    # Distance is ~500. Speed is 25. Takes ~20 frames.\n+    for _ in range(30):\n+        arena.handle_collisions(0.016)\n+        if disc.bounces > 0:\n+            break\n+    \n+    assert disc.bounces == 1\n+    \n+    # 2. Force max bounces to trigger explosion\n+    disc.bounces = 4\n+    arena.handle_collisions(0.016)\n+    \n+    assert not disc.active\n+    shards = [p for p in arena.projectiles if isinstance(p, DiscShard)]\n+    assert len(shards) == 8\n+    \n+    # 3. Move shards and check for hit\n+    # Move victim near the explosion\n+    # Shards spawn at disc.location.\n+    # One shard moves right [1, 0].\n+    # Victim width is 45. Place victim right where a right-moving shard will hit.\n+    # Disc location is center-ish.\n+    victim.location = [disc.location[0] + 20, disc.location[1]]\n+    initial_hp = victim.health\n+    \n+    # Run several frames to let shards travel\n+    for _ in range(10):\n+        arena.handle_collisions(0.016)\n+    \n+    assert victim.health < initial_hp, \"Victim should have been hit by at least one shard\"\n+\n+def test_ricochet_edge_case_corner_fire():\n+    \"\"\"Verify firing from a corner doesn't cause immediate stuck bouncing.\"\"\"\n+    arena = Arena(800, 600)\n+    # Fire from bottom-left corner [0, 0] towards top-right [800, 600]\n+    launcher = RicochetLauncher()\n+    projectiles = launcher.shoot(0, 0, 800, 600, \"player1\")\n+    disc = projectiles[0]\n+    arena.projectiles.append(disc)\n+    \n+    # Update a few frames\n+    for _ in range(5):\n+        arena.handle_collisions(0.016)\n+    \n+    # Should move away from corner\n+    assert disc.location[0] > 0\n+    assert disc.location[1] > 0\n+    # Should not have bounced yet\n+    assert disc.bounces == 0\n+    assert disc.active\n+\n+\n+if __name__ == \"__main__\":\n+    # Allow running this file directly for quick verification\n+    pytest.main([__file__])"}]}