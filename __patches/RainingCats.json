{"name_of_backup": "20260104161653_GameFolder", "changes": [{"path": "GameFolder/projectiles/CatProjectiles.py", "diff": "--- a/GameFolder/projectiles/CatProjectiles.py\n+++ b/GameFolder/projectiles/CatProjectiles.py\n@@ -0,0 +1,100 @@\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+import pygame\n+import math\n+import random\n+\n+class FallingCat(Projectile):\n+    def __init__(self, x, y, owner_id):\n+        # Direction: [0, -1] (World coordinates, moving down)\n+        # Size: ~20x20 pixels\n+        super().__init__(x, y, [0, -1], 10, 5, owner_id, 20, 20)\n+        self.color = (255, 165, 0)  # Orange\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+\n+        # Body (orange ellipse)\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+\n+        # Ears (two small triangles)\n+        ear_color = self.color\n+        # Left ear\n+        le_p1 = (py_rect.left, py_rect.top + 5)\n+        le_p2 = (py_rect.left + 5, py_rect.top - 5)\n+        le_p3 = (py_rect.left + 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [le_p1, le_p2, le_p3])\n+\n+        # Right ear\n+        re_p1 = (py_rect.right, py_rect.top + 5)\n+        re_p2 = (py_rect.right - 5, py_rect.top - 5)\n+        re_p3 = (py_rect.right - 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [re_p1, re_p2, re_p3])\n+\n+class CatCloud(Projectile):\n+    def __init__(self, x, y, target_pos, owner_id):\n+        # Travels to a target position, then stays there for a duration (e.g., 5.0s)\n+        super().__init__(x, y, [0, 0], 12, 0, owner_id, 80, 40)\n+        self.target_pos = target_pos\n+        self.is_raining = False\n+        self.cat_spawn_timer = 0.0\n+        self.rain_duration = 5.0\n+        self.rain_timer = 0.0\n+        self.spawn_interval = 0.2\n+        self.persistent = True # Keep it alive in the arena\n+\n+    def update(self, delta_time):\n+        if self.is_raining:\n+            # Stationary and raining\n+            self.rain_timer += delta_time\n+            if self.rain_timer >= self.rain_duration:\n+                self.active = False\n+        else:\n+            # Move towards target_pos\n+            dx = self.target_pos[0] - self.location[0]\n+            dy = self.target_pos[1] - self.location[1]\n+            dist = math.hypot(dx, dy)\n+            move_dist = self.speed * (delta_time * 60)\n+\n+            if dist <= move_dist:\n+                self.location[0] = self.target_pos[0]\n+                self.location[1] = self.target_pos[1]\n+                self.is_raining = True\n+            else:\n+                self.location[0] += (dx / dist) * move_dist\n+                self.location[1] += (dy / dist) * move_dist\n+        \n+        # Do NOT call super().update() because it would move based on self.direction\n+        # and potentially move it off target.\n+\n+    def spawn_cats(self, delta_time):\n+        new_cats = []\n+        if self.is_raining and self.active:\n+            self.cat_spawn_timer += delta_time\n+            while self.cat_spawn_timer >= self.spawn_interval:\n+                # Spawn at random x within cloud width\n+                spawn_x = self.location[0] + random.uniform(0, self.width - 20)\n+                spawn_y = self.location[1] # Start from cloud bottom/center\n+                new_cats.append(FallingCat(spawn_x, spawn_y, self.owner_id))\n+                self.cat_spawn_timer -= self.spawn_interval\n+        return new_cats\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        py_y = arena_height - self.location[1] - self.height\n+        \n+        # Fluffy white/gray cloud (multiple ellipses)\n+        cloud_color = (240, 240, 240)\n+        rects = [\n+            pygame.Rect(self.location[0], py_y + 10, self.width, self.height - 10),\n+            pygame.Rect(self.location[0] + 10, py_y, self.width - 20, self.height),\n+            pygame.Rect(self.location[0] + 20, py_y - 5, self.width - 40, self.height - 10)\n+        ]\n+        for r in rects:\n+            pygame.draw.ellipse(screen, cloud_color, r)"}, {"path": "GameFolder/weapons/CatRainGun.py", "diff": "--- a/GameFolder/weapons/CatRainGun.py\n+++ b/GameFolder/weapons/CatRainGun.py\n@@ -0,0 +1,18 @@\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.CatProjectiles import CatCloud\n+\n+class CatRainGun(Weapon):\n+    def __init__(self, location=None):\n+        # Name, damage (applied by spawned cats), cooldown, speed, location\n+        # Damage here is representative, actual damage depends on FallingCat.\n+        # Cooldown 5.0s as requested.\n+        super().__init__(\"Cat Rain Gun\", 5, 5.0, 12, location)\n+        self.color = (255, 165, 0)  # Orange like a ginger cat\n+\n+    def shoot(self, owner_x, owner_y, target_x, target_y, owner_id):\n+        \"\"\"\n+        Shoots a CatCloud projectile targeting the target location.\n+        \"\"\"\n+        target_pos = [target_x, target_y]\n+        # Create the CatCloud at the owner's position, heading to target_pos\n+        return CatCloud(owner_x, owner_y, target_pos, owner_id)"}, {"path": "GameFolder/setup.py", "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,7 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.CatRainGun import CatRainGun\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +45,9 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"Cat Rain Gun\", CatRainGun)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(CatRainGun([600, 400]))\n     \n     return arena"}, {"path": "GameFolder/arenas/GAME_arena.py", "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,8 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n import pygame\n import random\n import math\n@@ -26,6 +28,7 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"CatRainGun\", CatRainGun)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +50,7 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, CatCloud)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -141,6 +144,13 @@\n                             if dist < 50:\n                                 char.take_damage(proj.damage * delta_time * 60)\n             \n+            \n+            elif isinstance(proj, CatCloud) and proj.is_raining:\n+                # IMPORTANT: In this custom loop, self.projectiles is standard_projs\n+                # We must add to standard_projs so they are handled by super().handle_collisions\n+                # OR add to self.projectiles AFTER the loop, but here special_projs are NOT in self.projectiles.\n+                new_cats = proj.spawn_cats(delta_time)\n+                standard_projs.extend(new_cats)\n             \n             elif isinstance(proj, TornadoProjectile):\n                 # Conical pull logic: wider at top, pulls characters, weapons, and platforms\n"}, {"path": "GameFolder/tests/cat_rain_tests.py", "diff": "--- a/GameFolder/tests/cat_rain_tests.py\n+++ b/GameFolder/tests/cat_rain_tests.py\n@@ -0,0 +1,172 @@\n+import math\n+import pygame\n+import pytest\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.setup import setup_battle_arena\n+\n+def test_cat_rain_gun_properties():\n+    \"\"\"Verify CatRainGun initial properties.\"\"\"\n+    gun = CatRainGun()\n+    assert gun.name == \"Cat Rain Gun\"\n+    assert gun.cooldown == 5.0\n+    assert gun.color == (255, 165, 0)\n+\n+def test_cat_rain_gun_shooting():\n+    \"\"\"Verify CatRainGun spawns a CatCloud.\"\"\"\n+    gun = CatRainGun()\n+    gun.last_shot_time = 0 \n+    cloud = gun.shoot(100, 100, 200, 300, \"player1\")\n+    assert isinstance(cloud, CatCloud)\n+    assert cloud.target_pos == [200, 300]\n+    assert cloud.owner_id == \"player1\"\n+\n+def test_cat_cloud_movement():\n+    \"\"\"Verify CatCloud moves towards target then starts raining.\"\"\"\n+    # Start at 100,100 target 200,100. Speed 12.\n+    cloud = CatCloud(100, 100, [200, 100], \"player1\")\n+    assert not cloud.is_raining\n+    \n+    # Move partway. Speed=12, dt=0.1. move_dist = 12 * (0.1*60) = 72.\n+    cloud.update(0.1) \n+    assert cloud.location[0] == 172\n+    assert not cloud.is_raining\n+    \n+    # Move to target. Remaining dist = 28. Next move will be 72, which is > 28.\n+    cloud.update(0.1)\n+    assert cloud.is_raining, \"Cloud should be raining after reaching target\"\n+    assert cloud.location == [200, 100]\n+\n+def test_cat_cloud_spawning():\n+    \"\"\"Verify CatCloud spawns FallingCat projectiles when raining.\"\"\"\n+    cloud = CatCloud(200, 400, [200, 400], \"player1\")\n+    cloud.is_raining = True\n+    cloud.active = True\n+    \n+    # spawn_interval is 0.2\n+    cats = cloud.spawn_cats(0.1)\n+    assert len(cats) == 0\n+    \n+    cats = cloud.spawn_cats(0.15)\n+    assert len(cats) == 1\n+    assert isinstance(cats[0], FallingCat)\n+    assert cats[0].owner_id == \"player1\"\n+    # Spawned at cloud x (200) to 200+width-20 (200+80-20=260)\n+    assert 200 <= cats[0].location[0] <= 260\n+    assert cats[0].location[1] == 400\n+\n+def test_falling_cat_movement():\n+    \"\"\"Verify FallingCat moves downwards.\"\"\"\n+    cat = FallingCat(200, 400, \"player1\")\n+    # Speed 10, Direction [0, -1].\n+    # move_dist = 10 * (0.1 * 60) = 60.\n+    cat.update(0.1)\n+    assert cat.location[1] == 400 - 60\n+    assert cat.location[0] == 200\n+\n+def test_falling_cat_deals_damage():\n+    \"\"\"Verify FallingCat deals damage on collision in Arena.\"\"\"\n+    arena = Arena(800, 600)\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    target.id = \"target\"\n+    target.defense = 0\n+    arena.characters.append(target)\n+    \n+    # Cat falling right on target.\n+    # Character is at [200, 100], width 45.\n+    # Cat is at [210, 150], width 20.\n+    cat = FallingCat(210, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    initial_health = target.health\n+    \n+    # Run arena until collision\n+    # Cat speed 10. dist to target top is roughly 50.\n+    for _ in range(10):\n+        arena.handle_collisions(0.016)\n+        if target.health < initial_health:\n+            break\n+            \n+    assert target.health < initial_health\n+    assert target.health == initial_health - cat.damage\n+    assert not cat.active\n+\n+def test_cat_cloud_duration():\n+    \"\"\"Verify CatCloud deactivates after rain duration.\"\"\"\n+    cloud = CatCloud(100, 100, [100, 100], \"player1\")\n+    cloud.is_raining = True\n+    cloud.rain_timer = 0\n+    \n+    cloud.update(cloud.rain_duration - 0.1)\n+    assert cloud.active\n+    \n+    cloud.update(0.2)\n+    assert not cloud.active\n+\n+def test_cat_rain_gun_registration():\n+    \"\"\"Verify CatRainGun is registered in setup_battle_arena.\"\"\"\n+    arena = setup_battle_arena()\n+    # Check lootpool\n+    assert \"Cat Rain Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Cat Rain Gun\"] == CatRainGun\n+    \n+    # Check if one was spawned (as per setup.py)\n+    found = False\n+    for w in arena.weapon_pickups:\n+        if isinstance(w, CatRainGun):\n+            found = True\n+            break\n+    assert found, \"Cat Rain Gun should be spawned in the arena\"\n+\n+def test_integration_cat_cloud_in_arena():\n+    \"\"\"Verify CatCloud spawns cats inside the Arena update loop.\"\"\"\n+    arena = Arena(800, 600)\n+    cloud = CatCloud(200, 500, [200, 500], \"player1\")\n+    cloud.is_raining = True\n+    arena.projectiles.append(cloud)\n+    \n+    # Run for 0.5s. With spawn_interval 0.2, should spawn at least 2 cats.\n+    # handle_collisions(0.1) called 5 times.\n+    for _ in range(5):\n+        arena.handle_collisions(0.1)\n+        \n+    # Check if cats exist in arena.projectiles\n+    # Note: they might have fallen off or been removed if they hit floor, \n+    # but at speed 10, in 0.5s they move 10*60*0.5 = 300. \n+    # Starting at 500, they would be at 200. Floor is usually at 120 or 0.\n+    \n+    cats = [p for p in arena.projectiles if isinstance(p, FallingCat)]\n+    assert len(cats) >= 2\n+    assert cloud in arena.projectiles\n+\n+def test_falling_cat_hits_platform():\n+    \"\"\"Verify FallingCat is deactivated when hitting a platform.\"\"\"\n+    arena = Arena(800, 600)\n+    # Platform at Screen Y=500, Height 20. \n+    # World Y = 600 - 500 - 20 = 80.\n+    from GameFolder.platforms.GAME_platform import Platform\n+    plat = Platform(100, 500, 200, 20)\n+    arena.add_platform(plat)\n+    \n+    # Cat above platform\n+    cat = FallingCat(150, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    # Move cat down to hit platform\n+    for _ in range(20):\n+        arena.handle_collisions(0.016)\n+        if not cat.active:\n+            break\n+            \n+    assert not cat.active, \"Cat should deactivate on hitting platform\"\n+\n+def test_cat_cloud_diagonal_movement():\n+    \"\"\"Verify CatCloud moves correctly on diagonal path.\"\"\"\n+    cloud = CatCloud(0, 0, [100, 100], \"player1\")\n+    cloud.update(0.1) # move_dist = 72\n+    # Diagonal distance 141.4. move_dist 72.\n+    # move_x = (100/141.4) * 72 = 0.707 * 72 = 50.9\n+    assert 50 < cloud.location[0] < 52\n+    assert 50 < cloud.location[1] < 52"}]}