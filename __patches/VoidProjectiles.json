{"name_of_backup": "20260104161653_GameFolder", "changes": [{"path": "GameFolder/projectiles/VoidProjectiles.py", "diff": "--- a/GameFolder/projectiles/VoidProjectiles.py\n+++ b/GameFolder/projectiles/VoidProjectiles.py\n@@ -0,0 +1,46 @@\n+import math\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class VoidOrb(Projectile):\n+    def __init__(self, x, y, direction, owner_id):\n+        # width=40, height=40, speed=3.0, damage=5.0, color=(75, 0, 130)\n+        super().__init__(x, y, direction, 3.0, 5.0, owner_id, 40, 40)\n+        self.color = (75, 0, 130)\n+        self.bolt_timer = 0.0\n+        self.bolt_interval = 0.5\n+\n+    def update(self, delta_time):\n+        super().update(delta_time)\n+        self.bolt_timer += delta_time\n+\n+class VoidBolt(Projectile):\n+    def __init__(self, x, y, target_character, owner_id):\n+        # width=10, height=10, speed=10.0, damage=12.0, color=(255, 0, 255)\n+        # Initial direction is toward target center\n+        dx = target_character.location[0] + target_character.width / 2 - x\n+        dy = target_character.location[1] + target_character.height / 2 - y\n+        dist = math.hypot(dx, dy)\n+        if dist > 0:\n+            direction = [dx / dist, dy / dist]\n+        else:\n+            direction = [1, 0]\n+\n+        super().__init__(x, y, direction, 10.0, 12.0, owner_id, 10, 10)\n+        self.color = (255, 0, 255)\n+        self.target = target_character\n+\n+    def update(self, delta_time):\n+        # Recalculate direction towards target.location (center)\n+        # Ensure it handles the case where target is dead by continuing in its last direction.\n+        if self.target and self.target.is_alive:\n+            target_center_x = self.target.location[0] + self.target.width / 2\n+            target_center_y = self.target.location[1] + self.target.height / 2\n+            \n+            dx = target_center_x - (self.location[0] + self.width / 2)\n+            dy = target_center_y - (self.location[1] + self.height / 2)\n+            \n+            dist = math.hypot(dx, dy)\n+            if dist > 0:\n+                self.direction = [dx / dist, dy / dist]\n+        \n+        super().update(delta_time)"}, {"path": "GameFolder/weapons/VoidReaper.py", "diff": "--- a/GameFolder/weapons/VoidReaper.py\n+++ b/GameFolder/weapons/VoidReaper.py\n@@ -0,0 +1,28 @@\n+import math\n+import time\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.VoidProjectiles import VoidOrb\n+\n+class VoidReaper(Weapon):\n+    def __init__(self, location=None):\n+        super().__init__(\n+            name=\"Void Reaper\",\n+            damage=5,\n+            cooldown=2.0,\n+            projectile_speed=3.0,\n+            location=location\n+        )\n+        self.color = (100, 0, 200)\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        if not self.can_shoot():\n+            return None\n+\n+        self.last_shot_time = time.time()\n+\n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist != 0 else [1, 0]\n+\n+        return [VoidOrb(owner_x, owner_y, direction, owner_id)]"}, {"path": "GameFolder/arenas/GAME_arena.py", "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,8 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.projectiles.VoidProjectiles import VoidOrb, VoidBolt\n+from GameFolder.weapons.VoidReaper import VoidReaper\n import pygame\n import random\n import math\n@@ -23,14 +25,15 @@\n             self.platforms[0] = Platform(floor.rect.x, floor.rect.y, floor.rect.width, floor.rect.height, floor.color)\n             \n         # Register custom weapons\n+        self.register_weapon_type(\"StormBringer\", StormBringer)\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n-        self.register_weapon_type(\"TornadoGun\", TornadoGun)\n-        self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n-        \n+        self.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n+        self.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+        self.register_weapon_type(\"Void Reaper\", VoidReaper)\n+\n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n         self.sky_color = (100, 150, 255)\n-        \n         # Use custom UI\n         self.ui = GameUI(self.screen, self.width, self.height)\n \n@@ -47,7 +50,7 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, VoidOrb, VoidBolt)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -226,6 +229,60 @@\n                     char_w = char.width * char.scale_ratio\n                     if char.location[0] < beam_x_max and char.location[0] + char_w > beam_x_min:\n                         char.take_damage(proj.damage * delta_time)\n+\n+            elif isinstance(proj, VoidOrb):\n+                # Spawning logic\n+                if proj.bolt_timer >= proj.bolt_interval:\n+                    proj.bolt_timer = 0\n+                    nearest_char = None\n+                    min_dist = 300\n+                    \n+                    orb_center_x = proj.location[0] + proj.width / 2\n+                    orb_center_y = proj.location[1] + proj.height / 2\n+\n+                    for char in self.characters:\n+                        if not char.is_alive or char.id == proj.owner_id:\n+                            continue\n+                        char_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+                        char_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+                        dist = math.hypot(char_center_x - orb_center_x, char_center_y - orb_center_y)\n+                        if dist < min_dist:\n+                            min_dist = dist\n+                            nearest_char = char\n+                    \n+                    if nearest_char:\n+                        bolt = VoidBolt(orb_center_x, orb_center_y, nearest_char, proj.owner_id)\n+                        self.projectiles.append(bolt)\n+\n+                # Contact damage\n+                orb_rect = pygame.Rect(proj.location[0], self.height - proj.location[1] - proj.height, proj.width, proj.height)\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id:\n+                        continue\n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    if orb_rect.colliderect(char_rect):\n+                        char.take_damage(proj.damage * delta_time * 60)\n+\n+            elif isinstance(proj, VoidBolt):\n+                proj_x = proj.location[0]\n+                proj_y = self.height - proj.location[1] - proj.height\n+                bolt_rect = pygame.Rect(proj_x, proj_y, proj.width, proj.height)\n+                \n+                # Platform collisions\n+                for plat in self.platforms:\n+                    if bolt_rect.colliderect(plat.rect):\n+                        proj.active = False\n+                        break\n+\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id: continue\n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    if bolt_rect.colliderect(char_rect):\n+                        char.take_damage(proj.damage)\n+                        proj.active = False\n+                        break\n             \n             # Put persistent projectile back into active list\n             if proj.active:\n"}, {"path": "GameFolder/setup.py", "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -1,4 +1,3 @@\n-from ast import Or\n from GameFolder.arenas.GAME_arena import Arena\n from GameFolder.characters.GAME_character import Character\n from GameFolder.platforms.GAME_platform import Platform\n@@ -6,6 +5,7 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.VoidReaper import VoidReaper\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,6 +44,7 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"Void Reaper\", VoidReaper)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n     \n"}, {"path": "GameFolder/tests/void_reaper_tests.py", "diff": "--- a/GameFolder/tests/void_reaper_tests.py\n+++ b/GameFolder/tests/void_reaper_tests.py\n@@ -0,0 +1,180 @@\n+\"\"\"\n+Tests for Void Reaper Weapon and its Projectiles (VoidOrb, VoidBolt)\n+\"\"\"\n+\n+import math\n+import pygame\n+from GameFolder.weapons.VoidReaper import VoidReaper\n+from GameFolder.projectiles.VoidProjectiles import VoidOrb, VoidBolt\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.setup import setup_battle_arena\n+\n+def test_void_orb_properties():\n+    \"\"\"Verify VoidOrb initial properties.\"\"\"\n+    orb = VoidOrb(100, 100, [1, 0], \"player1\")\n+    assert orb.width == 40\n+    assert orb.height == 40\n+    assert orb.speed == 3.0\n+    assert orb.damage == 5.0\n+    assert orb.color == (75, 0, 130)\n+    assert orb.bolt_timer == 0.0\n+    assert orb.bolt_interval == 0.5\n+\n+def test_void_bolt_properties():\n+    \"\"\"Verify VoidBolt initial properties.\"\"\"\n+    target = Character(\"Target\", \"\", \"\", [200, 200])\n+    bolt = VoidBolt(100, 100, target, \"player1\")\n+    assert bolt.width == 10\n+    assert bolt.height == 10\n+    assert bolt.speed == 10.0\n+    assert bolt.damage == 12.0\n+    assert bolt.color == (255, 0, 255)\n+    assert bolt.target == target\n+\n+def test_void_reaper_properties():\n+    \"\"\"Verify VoidReaper initial properties.\"\"\"\n+    gun = VoidReaper()\n+    assert gun.name == \"Void Reaper\"\n+    assert gun.damage == 5\n+    assert gun.cooldown == 2.0\n+    assert gun.projectile_speed == 3.0\n+\n+def test_void_reaper_shooting():\n+    \"\"\"Verify VoidReaper spawns a VoidOrb.\"\"\"\n+    gun = VoidReaper()\n+    gun.last_shot_time = 0\n+    projectiles = gun.shoot(100, 100, 200, 100, \"player1\")\n+    assert len(projectiles) == 1\n+    assert isinstance(projectiles[0], VoidOrb)\n+    assert projectiles[0].owner_id == \"player1\"\n+\n+def test_void_bolt_tracking():\n+    \"\"\"Verify VoidBolt tracks its target.\"\"\"\n+    target = Character(\"Target\", \"\", \"\", [200, 200])\n+    bolt = VoidBolt(100, 100, target, \"player1\")\n+    \n+    # Move target\n+    target.location = [300, 300]\n+    bolt.update(0.016)\n+    \n+    # Calculate expected direction\n+    dx = (300 + target.width / 2) - (bolt.location[0] + bolt.width / 2)\n+    dy = (300 + target.height / 2) - (bolt.location[1] + bolt.height / 2)\n+    dist = math.hypot(dx, dy)\n+    expected_dir = [dx / dist, dy / dist]\n+    \n+    assert math.isclose(bolt.direction[0], expected_dir[0], rel_tol=1e-5)\n+    assert math.isclose(bolt.direction[1], expected_dir[1], rel_tol=1e-5)\n+\n+def test_void_orb_spawning_bolts_integration():\n+    \"\"\"Verify Arena handles VoidOrb spawning VoidBolts.\"\"\"\n+    pygame.init()\n+    arena = Arena(800, 600)\n+    orb = VoidOrb(400, 300, [0, 0], \"attacker\")\n+    arena.projectiles.append(orb)\n+    \n+    # Target within 300 units\n+    target = Character(\"Target\", \"\", \"\", [450, 350])\n+    target.id = \"target_id\"\n+    arena.characters.append(target)\n+    \n+    # Step frames until bolt_interval (0.5s)\n+    dt = 0.016\n+    frames = int(0.6 / dt)\n+    for _ in range(frames):\n+        arena.handle_collisions(dt)\n+        \n+    # Check if a VoidBolt was spawned\n+    bolts = [p for p in arena.projectiles if isinstance(p, VoidBolt)]\n+    assert len(bolts) > 0, \"VoidOrb should have spawned at least one VoidBolt\"\n+    assert bolts[0].target == target\n+\n+def test_void_orb_contact_damage_integration():\n+    \"\"\"Verify VoidOrb deals contact damage over time.\"\"\"\n+    arena = Arena(800, 600)\n+    orb = VoidOrb(400, 300, [0, 0], \"attacker\")\n+    arena.projectiles.append(orb)\n+    \n+    # Character overlapping with orb\n+    # Orb is 40x40 at (400, 300). Rect (400, 300, 40, 40) - logic coord\n+    # Character 50x50. Let's place it at (400, 300)\n+    target = Character(\"Target\", \"\", \"\", [400, 300])\n+    target.id = \"target_id\"\n+    arena.characters.append(target)\n+    \n+    initial_health = target.health\n+    dt = 0.1\n+    arena.handle_collisions(dt)\n+    \n+    # damage * delta_time * 60 = 5.0 * 0.1 * 60 = 30\n+    # But take_damage subtracts defense (default 5). 30 - 5 = 25.\n+    assert target.health < initial_health\n+    assert target.health == initial_health - 25\n+\n+def test_void_bolt_collision_integration():\n+    \"\"\"Verify VoidBolt deals damage and deactivates on hit.\"\"\"\n+    arena = Arena(800, 600)\n+    target = Character(\"Target\", \"\", \"\", [400, 300])\n+    target.id = \"target_id\"\n+    arena.characters.append(target)\n+    \n+    # Create bolt right on top of target\n+    bolt = VoidBolt(400, 300, target, \"attacker\")\n+    arena.projectiles.append(bolt)\n+    \n+    initial_health = target.health\n+    arena.handle_collisions(0.016)\n+    \n+    assert not bolt.active, \"Bolt should deactivate on collision\"\n+    # Bolt damage is 12. Defense is 5. 12 - 5 = 7.\n+    assert target.health == initial_health - 7\n+\n+def test_void_reaper_edge_case_no_target():\n+    \"\"\"Verify VoidOrb doesn't spawn bolts if no target is in range.\"\"\"\n+    arena = Arena(800, 600)\n+    orb = VoidOrb(400, 300, [0, 0], \"attacker\")\n+    arena.projectiles.append(orb)\n+    \n+    # Target too far away (> 300 units)\n+    target = Character(\"Target\", \"\", \"\", [750, 550])\n+    target.id = \"target_id\"\n+    arena.characters.append(target)\n+    \n+    dt = 0.016\n+    frames = int(0.6 / dt)\n+    for _ in range(frames):\n+        arena.handle_collisions(dt)\n+        \n+    bolts = [p for p in arena.projectiles if isinstance(p, VoidBolt)]\n+    assert len(bolts) == 0, \"VoidOrb should not spawn bolts if no target is in range\"\n+\n+def test_void_reaper_registration():\n+    \"\"\"Verify Void Reaper is in the lootpool.\"\"\"\n+    arena = setup_battle_arena()\n+    assert \"Void Reaper\" in arena.lootpool\n+\n+def test_void_bolt_tracking_dead_target():\n+    \"\"\"Verify VoidBolt continues in last direction if target dies.\"\"\"\n+    target = Character(\"Target\", \"\", \"\", [200, 200])\n+    bolt = VoidBolt(100, 100, target, \"player1\")\n+    \n+    # Get initial direction\n+    initial_dir = bolt.direction[:]\n+    \n+    # Kill target\n+    target.health = 0\n+    target.is_alive = False\n+    \n+    # Move target to a new location\n+    target.location = [500, 500]\n+    \n+    bolt.update(0.016)\n+    \n+    # Direction should NOT have changed to follow the dead target's new (unrealistic) position\n+    assert bolt.direction == initial_dir\n+\n+if __name__ == \"__main__\":\n+    # Manual test run\n+    test_void_orb_properties()\n+    print(\"All tests passed!\")"}]}