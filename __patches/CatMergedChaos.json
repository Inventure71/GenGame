{
  "name_of_backup": "20260104161653_GameFolder",
  "changes": [
    {
      "path": "GameFolder/arenas/GAME_arena.py",
      "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,13 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.ChaosEngine import ChaosEngine, RealityResetProjectile\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n import pygame\n import random\n import math\n@@ -26,6 +33,11 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"ChaosEngine\", ChaosEngine)\n+        self.register_weapon_type(\"CatRainGun\", CatRainGun)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +59,11 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, ChaosBolt, AnomalyOrb, RealityResetProjectile, CatCloud)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -61,23 +77,75 @@\n         \n         # Manually handle special/persistent projectiles\n         for proj in special_projs:\n-            # Special case for OrbitalStrikeMarker: check transition even if inactive at start of loop\n-            if isinstance(proj, OrbitalStrikeMarker) and not proj.active:\n+            # Update if active\n+            if proj.active:\n+                proj.update(delta_time)\n+\n+            # Post-update check: Handle transitions for special projectiles that just became inactive\n+            if not proj.active and isinstance(proj, OrbitalStrikeMarker):\n                 blast = OrbitalBlast(proj.location[0], proj.owner_id)\n                 if blast not in self.projectiles:\n                     self.projectiles.append(blast)\n-                continue\n+                continue # Don't re-add marker to active projectiles\n+\n+            if proj.active and isinstance(proj, ChaosBolt):\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id: continue\n+                    \n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    \n+                    proj_rect = pygame.Rect(proj.location[0], self.height - proj.location[1] - proj.height, proj.width, proj.height)\n+                    \n+                    if char_rect.colliderect(proj_rect):\n+                        char.take_damage(proj.damage)\n+                        proj.active = False\n+                        \n+                        # Chaos Bolt Hit Effect\n+                        effect = random.randint(0, 3)\n+                        if effect == 0: # Swap locations\n+                            owner = next((c for c in self.characters if c.id == proj.owner_id), None)\n+                            if owner:\n+                                owner.location, char.location = list(char.location), list(owner.location)\n+                        elif effect == 1: # Random scale\n+                            char.scale_ratio = random.uniform(0.5, 2.0)\n+                        elif effect == 2: # Inverted physics\n+                            char.physics_inverted = True\n+                            if not hasattr(char, 'chaos_timer'): char.chaos_timer = 0\n+                            char.chaos_timer = 3.0\n+                        elif effect == 3: # Launch upwards\n+                            char.vertical_velocity = 25.0\n+\n+            elif not proj.active and isinstance(proj, AnomalyOrb):\n+                # Reached target or collided\n+                spawn_type = random.choice([BlackHoleProjectile, TornadoProjectile, StormCloud])\n+                new_proj = None\n+                if spawn_type == BlackHoleProjectile:\n+                    new_proj = BlackHoleProjectile(proj.location[0], proj.location[1], proj.location[0], proj.location[1], proj.owner_id)\n+                elif spawn_type == TornadoProjectile:\n+                    new_proj = TornadoProjectile(proj.location[0], proj.location[1], [0, 1], 0.5, proj.owner_id)\n+                elif spawn_type == StormCloud:\n+                    new_proj = StormCloud(proj.location[0], proj.location[1], proj.location, proj.owner_id)\n+                \n+                if new_proj:\n+                    self.projectiles.append(new_proj)\n+                continue # Don't re-add orb\n+\n+            elif not proj.active and isinstance(proj, RealityResetProjectile):\n+                # Reality Reset: Shuffle characters and weapon pickups\n+                spawn_points = [list(c.location) for c in self.characters]\n+                spawn_points.extend([list(w.location) for w in self.weapon_pickups])\n+                random.shuffle(spawn_points)\n+                \n+                for char in self.characters:\n+                    if spawn_points:\n+                        char.location = spawn_points.pop()\n+                for weapon in self.weapon_pickups:\n+                    if spawn_points:\n+                        weapon.location = spawn_points.pop()\n+                continue # Don't re-add reset projectile\n \n             if not proj.active:\n-                continue\n-                \n-            proj.update(delta_time)\n-\n-            # Check if OrbitalStrikeMarker became inactive during update\n-            if isinstance(proj, OrbitalStrikeMarker) and not proj.active:\n-                blast = OrbitalBlast(proj.location[0], proj.owner_id)\n-                if blast not in self.projectiles:\n-                    self.projectiles.append(blast)\n                 continue\n \n             if isinstance(proj, StormCloud):\n@@ -142,6 +210,12 @@\n                                 char.take_damage(proj.damage * delta_time * 60)\n             \n             \n+            elif isinstance(proj, CatCloud) and proj.is_raining:\n+                # IMPORTANT: In this custom loop, self.projectiles is standard_projs\n+                # We must add to standard_projs so they are handled by super().handle_collisions\n+                # OR add to self.projectiles AFTER the loop, but here special_projs are NOT in self.projectiles.\n+                new_cats = proj.spawn_cats(delta_time)\n+                standard_projs.extend(new_cats)\n             elif isinstance(proj, TornadoProjectile):\n                 # Conical pull logic: wider at top, pulls characters, weapons, and platforms\n                 for char in self.characters:\n@@ -237,6 +311,12 @@\n                 if proj in self.projectiles:\n                     self.projectiles.remove(proj)\n \n+        # Handle character chaos timer (inverted physics)\n+        for char in self.characters:\n+            if hasattr(char, 'chaos_timer') and char.chaos_timer > 0:\n+                char.chaos_timer -= delta_time\n+                if char.chaos_timer <= 0:\n+                    char.physics_inverted = False\n         for plat in self.platforms[1:]: # Skip floor\n             if not getattr(plat, 'being_pulled', False):\n                 plat.return_to_origin(delta_time)"
    },
    {
      "path": "GameFolder/projectiles/CatProjectiles.py",
      "diff": "--- a/GameFolder/projectiles/CatProjectiles.py\n+++ b/GameFolder/projectiles/CatProjectiles.py\n@@ -0,0 +1,100 @@\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+import pygame\n+import math\n+import random\n+\n+class FallingCat(Projectile):\n+    def __init__(self, x, y, owner_id):\n+        # Direction: [0, -1] (World coordinates, moving down)\n+        # Size: ~20x20 pixels\n+        super().__init__(x, y, [0, -1], 10, 5, owner_id, 20, 20)\n+        self.color = (255, 165, 0)  # Orange\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+\n+        # Body (orange ellipse)\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+\n+        # Ears (two small triangles)\n+        ear_color = self.color\n+        # Left ear\n+        le_p1 = (py_rect.left, py_rect.top + 5)\n+        le_p2 = (py_rect.left + 5, py_rect.top - 5)\n+        le_p3 = (py_rect.left + 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [le_p1, le_p2, le_p3])\n+\n+        # Right ear\n+        re_p1 = (py_rect.right, py_rect.top + 5)\n+        re_p2 = (py_rect.right - 5, py_rect.top - 5)\n+        re_p3 = (py_rect.right - 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [re_p1, re_p2, re_p3])\n+\n+class CatCloud(Projectile):\n+    def __init__(self, x, y, target_pos, owner_id):\n+        # Travels to a target position, then stays there for a duration (e.g., 5.0s)\n+        super().__init__(x, y, [0, 0], 12, 0, owner_id, 80, 40)\n+        self.target_pos = target_pos\n+        self.is_raining = False\n+        self.cat_spawn_timer = 0.0\n+        self.rain_duration = 5.0\n+        self.rain_timer = 0.0\n+        self.spawn_interval = 0.2\n+        self.persistent = True # Keep it alive in the arena\n+\n+    def update(self, delta_time):\n+        if self.is_raining:\n+            # Stationary and raining\n+            self.rain_timer += delta_time\n+            if self.rain_timer >= self.rain_duration:\n+                self.active = False\n+        else:\n+            # Move towards target_pos\n+            dx = self.target_pos[0] - self.location[0]\n+            dy = self.target_pos[1] - self.location[1]\n+            dist = math.hypot(dx, dy)\n+            move_dist = self.speed * (delta_time * 60)\n+\n+            if dist <= move_dist:\n+                self.location[0] = self.target_pos[0]\n+                self.location[1] = self.target_pos[1]\n+                self.is_raining = True\n+            else:\n+                self.location[0] += (dx / dist) * move_dist\n+                self.location[1] += (dy / dist) * move_dist\n+        \n+        # Do NOT call super().update() because it would move based on self.direction\n+        # and potentially move it off target.\n+\n+    def spawn_cats(self, delta_time):\n+        new_cats = []\n+        if self.is_raining and self.active:\n+            self.cat_spawn_timer += delta_time\n+            while self.cat_spawn_timer >= self.spawn_interval:\n+                # Spawn at random x within cloud width\n+                spawn_x = self.location[0] + random.uniform(0, self.width - 20)\n+                spawn_y = self.location[1] # Start from cloud bottom/center\n+                new_cats.append(FallingCat(spawn_x, spawn_y, self.owner_id))\n+                self.cat_spawn_timer -= self.spawn_interval\n+        return new_cats\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        py_y = arena_height - self.location[1] - self.height\n+        \n+        # Fluffy white/gray cloud (multiple ellipses)\n+        cloud_color = (240, 240, 240)\n+        rects = [\n+            pygame.Rect(self.location[0], py_y + 10, self.width, self.height - 10),\n+            pygame.Rect(self.location[0] + 10, py_y, self.width - 20, self.height),\n+            pygame.Rect(self.location[0] + 20, py_y - 5, self.width - 40, self.height - 10)\n+        ]\n+        for r in rects:\n+            pygame.draw.ellipse(screen, cloud_color, r)"
    },
    {
      "path": "GameFolder/projectiles/ChaosProjectiles.py",
      "diff": "--- a/GameFolder/projectiles/ChaosProjectiles.py\n+++ b/GameFolder/projectiles/ChaosProjectiles.py\n@@ -0,0 +1,61 @@\n+import pygame\n+import math\n+import time\n+import colorsys\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class ChaosBolt(Projectile):\n+    def __init__(self, x: float, y: float, direction: list[float, float], speed: float, damage: float, owner_id: str):\n+        # Faster than normal projectiles (multiplier applied here or in weapon)\n+        super().__init__(x, y, direction, speed, damage, owner_id, width=12, height=12)\n+        self.frequency = 2.0  # Speed of color shifting\n+\n+    def update(self, delta_time: float):\n+        super().update(delta_time)\n+        # Update color with rainbow-shifting HSL\n+        hue = (time.time() * self.frequency) % 1.0\n+        rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)\n+        self.color = (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        \n+        # Draw with a slight trail or glow effect using the rainbow color\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+        # Glitchy inner core\n+        inner_color = (255 - self.color[0], 255 - self.color[1], 255 - self.color[2])\n+        inner_rect = py_rect.inflate(-4, -4)\n+        pygame.draw.ellipse(screen, inner_color, inner_rect)\n+\n+class AnomalyOrb(Projectile):\n+    def __init__(self, x: float, y: float, target_pos: list[float, float], owner_id: str):\n+        # Travels towards target_pos\n+        dx = target_pos[0] - x\n+        dy = target_pos[1] - y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist > 0 else [0, 0]\n+        \n+        super().__init__(x, y, direction, speed=8, damage=0, owner_id=owner_id, width=20, height=20)\n+        self.target_pos = target_pos\n+        self.color = (150, 0, 200) # Purple/Anomaly color\n+\n+    def update(self, delta_time: float):\n+        dx = self.target_pos[0] - self.location[0]\n+        dy = self.target_pos[1] - self.location[1]\n+        dist = math.hypot(dx, dy)\n+        \n+        move_dist = self.speed * (delta_time * 60)\n+        \n+        if dist <= move_dist:\n+            self.location[0] = self.target_pos[0]\n+            self.location[1] = self.target_pos[1]\n+            # When it reaches target_pos, it sets active = False \n+            # Arena should spawn random persistent projectile here\n+            self.active = False\n+        else:\n+            self.location[0] += self.direction[0] * move_dist\n+            self.location[1] += self.direction[1] * move_dist"
    },
    {
      "path": "GameFolder/setup.py",
      "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,11 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.ChaosEngine import ChaosEngine\n+from GameFolder.weapons.CatRainGun import CatRainGun\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +49,17 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"The Chaos Engine\", ChaosEngine)\n+    arena.register_weapon_type(\"Cat Rain Gun\", CatRainGun)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(ChaosEngine([600, 100]))\n+    arena.spawn_weapon(CatRainGun([600, 400]))\n     \n     return arena"
    },
    {
      "path": "GameFolder/tests/cat_rain_tests.py",
      "diff": "--- a/GameFolder/tests/cat_rain_tests.py\n+++ b/GameFolder/tests/cat_rain_tests.py\n@@ -0,0 +1,172 @@\n+import math\n+import pygame\n+import pytest\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.setup import setup_battle_arena\n+\n+def test_cat_rain_gun_properties():\n+    \"\"\"Verify CatRainGun initial properties.\"\"\"\n+    gun = CatRainGun()\n+    assert gun.name == \"Cat Rain Gun\"\n+    assert gun.cooldown == 5.0\n+    assert gun.color == (255, 165, 0)\n+\n+def test_cat_rain_gun_shooting():\n+    \"\"\"Verify CatRainGun spawns a CatCloud.\"\"\"\n+    gun = CatRainGun()\n+    gun.last_shot_time = 0 \n+    cloud = gun.shoot(100, 100, 200, 300, \"player1\")\n+    assert isinstance(cloud, CatCloud)\n+    assert cloud.target_pos == [200, 300]\n+    assert cloud.owner_id == \"player1\"\n+\n+def test_cat_cloud_movement():\n+    \"\"\"Verify CatCloud moves towards target then starts raining.\"\"\"\n+    # Start at 100,100 target 200,100. Speed 12.\n+    cloud = CatCloud(100, 100, [200, 100], \"player1\")\n+    assert not cloud.is_raining\n+    \n+    # Move partway. Speed=12, dt=0.1. move_dist = 12 * (0.1*60) = 72.\n+    cloud.update(0.1) \n+    assert cloud.location[0] == 172\n+    assert not cloud.is_raining\n+    \n+    # Move to target. Remaining dist = 28. Next move will be 72, which is > 28.\n+    cloud.update(0.1)\n+    assert cloud.is_raining, \"Cloud should be raining after reaching target\"\n+    assert cloud.location == [200, 100]\n+\n+def test_cat_cloud_spawning():\n+    \"\"\"Verify CatCloud spawns FallingCat projectiles when raining.\"\"\"\n+    cloud = CatCloud(200, 400, [200, 400], \"player1\")\n+    cloud.is_raining = True\n+    cloud.active = True\n+    \n+    # spawn_interval is 0.2\n+    cats = cloud.spawn_cats(0.1)\n+    assert len(cats) == 0\n+    \n+    cats = cloud.spawn_cats(0.15)\n+    assert len(cats) == 1\n+    assert isinstance(cats[0], FallingCat)\n+    assert cats[0].owner_id == \"player1\"\n+    # Spawned at cloud x (200) to 200+width-20 (200+80-20=260)\n+    assert 200 <= cats[0].location[0] <= 260\n+    assert cats[0].location[1] == 400\n+\n+def test_falling_cat_movement():\n+    \"\"\"Verify FallingCat moves downwards.\"\"\"\n+    cat = FallingCat(200, 400, \"player1\")\n+    # Speed 10, Direction [0, -1].\n+    # move_dist = 10 * (0.1 * 60) = 60.\n+    cat.update(0.1)\n+    assert cat.location[1] == 400 - 60\n+    assert cat.location[0] == 200\n+\n+def test_falling_cat_deals_damage():\n+    \"\"\"Verify FallingCat deals damage on collision in Arena.\"\"\"\n+    arena = Arena(800, 600)\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    target.id = \"target\"\n+    target.defense = 0\n+    arena.characters.append(target)\n+    \n+    # Cat falling right on target.\n+    # Character is at [200, 100], width 45.\n+    # Cat is at [210, 150], width 20.\n+    cat = FallingCat(210, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    initial_health = target.health\n+    \n+    # Run arena until collision\n+    # Cat speed 10. dist to target top is roughly 50.\n+    for _ in range(10):\n+        arena.handle_collisions(0.016)\n+        if target.health < initial_health:\n+            break\n+            \n+    assert target.health < initial_health\n+    assert target.health == initial_health - cat.damage\n+    assert not cat.active\n+\n+def test_cat_cloud_duration():\n+    \"\"\"Verify CatCloud deactivates after rain duration.\"\"\"\n+    cloud = CatCloud(100, 100, [100, 100], \"player1\")\n+    cloud.is_raining = True\n+    cloud.rain_timer = 0\n+    \n+    cloud.update(cloud.rain_duration - 0.1)\n+    assert cloud.active\n+    \n+    cloud.update(0.2)\n+    assert not cloud.active\n+\n+def test_cat_rain_gun_registration():\n+    \"\"\"Verify CatRainGun is registered in setup_battle_arena.\"\"\"\n+    arena = setup_battle_arena()\n+    # Check lootpool\n+    assert \"Cat Rain Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Cat Rain Gun\"] == CatRainGun\n+    \n+    # Check if one was spawned (as per setup.py)\n+    found = False\n+    for w in arena.weapon_pickups:\n+        if isinstance(w, CatRainGun):\n+            found = True\n+            break\n+    assert found, \"Cat Rain Gun should be spawned in the arena\"\n+\n+def test_integration_cat_cloud_in_arena():\n+    \"\"\"Verify CatCloud spawns cats inside the Arena update loop.\"\"\"\n+    arena = Arena(800, 600)\n+    cloud = CatCloud(200, 500, [200, 500], \"player1\")\n+    cloud.is_raining = True\n+    arena.projectiles.append(cloud)\n+    \n+    # Run for 0.5s. With spawn_interval 0.2, should spawn at least 2 cats.\n+    # handle_collisions(0.1) called 5 times.\n+    for _ in range(5):\n+        arena.handle_collisions(0.1)\n+        \n+    # Check if cats exist in arena.projectiles\n+    # Note: they might have fallen off or been removed if they hit floor, \n+    # but at speed 10, in 0.5s they move 10*60*0.5 = 300. \n+    # Starting at 500, they would be at 200. Floor is usually at 120 or 0.\n+    \n+    cats = [p for p in arena.projectiles if isinstance(p, FallingCat)]\n+    assert len(cats) >= 2\n+    assert cloud in arena.projectiles\n+\n+def test_falling_cat_hits_platform():\n+    \"\"\"Verify FallingCat is deactivated when hitting a platform.\"\"\"\n+    arena = Arena(800, 600)\n+    # Platform at Screen Y=500, Height 20. \n+    # World Y = 600 - 500 - 20 = 80.\n+    from GameFolder.platforms.GAME_platform import Platform\n+    plat = Platform(100, 500, 200, 20)\n+    arena.add_platform(plat)\n+    \n+    # Cat above platform\n+    cat = FallingCat(150, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    # Move cat down to hit platform\n+    for _ in range(20):\n+        arena.handle_collisions(0.016)\n+        if not cat.active:\n+            break\n+            \n+    assert not cat.active, \"Cat should deactivate on hitting platform\"\n+\n+def test_cat_cloud_diagonal_movement():\n+    \"\"\"Verify CatCloud moves correctly on diagonal path.\"\"\"\n+    cloud = CatCloud(0, 0, [100, 100], \"player1\")\n+    cloud.update(0.1) # move_dist = 72\n+    # Diagonal distance 141.4. move_dist 72.\n+    # move_x = (100/141.4) * 72 = 0.707 * 72 = 50.9\n+    assert 50 < cloud.location[0] < 52\n+    assert 50 < cloud.location[1] < 52"
    },
    {
      "path": "GameFolder/tests/test_chaos_engine.py",
      "diff": "--- a/GameFolder/tests/test_chaos_engine.py\n+++ b/GameFolder/tests/test_chaos_engine.py\n@@ -0,0 +1,188 @@\n+import pytest\n+import pygame\n+import time\n+import random\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.weapons.ChaosEngine import ChaosEngine, RealityResetProjectile\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.projectiles.BlackHoleProjectile import BlackHoleProjectile\n+from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n+from GameFolder.projectiles.GAME_projectile import StormCloud\n+\n+def test_chaos_engine_initialization():\n+    weapon = ChaosEngine([100, 100])\n+    assert weapon.name == \"The Chaos Engine\"\n+    assert weapon.damage == 15\n+    assert weapon.projectile_speed == 25.0\n+    assert weapon.secondary_cooldown == 4.0\n+    assert weapon.special_cooldown == 12.0\n+\n+def test_chaos_bolt_mechanics():\n+    shooter_id = \"shooter\"\n+    bolt = ChaosBolt(100, 100, [1, 0], 25.0, 15.0, shooter_id)\n+    \n+    # Test movement\n+    bolt.update(0.016)\n+    assert bolt.location[0] > 100\n+    \n+    # Test color update (rainbow shifting)\n+    initial_color = bolt.color\n+    time.sleep(0.1) # Ensure time passes for color shift\n+    bolt.update(0.016)\n+    assert bolt.color != initial_color\n+\n+def test_anomaly_orb_movement_and_deactivation():\n+    target_pos = [200, 200]\n+    orb = AnomalyOrb(100, 100, target_pos, \"owner\")\n+    \n+    # Simulate movement until it reaches target\n+    for _ in range(200):\n+        orb.update(0.016)\n+        if not orb.active:\n+            break\n+            \n+    assert orb.active is False\n+    assert orb.location[0] == pytest.approx(target_pos[0])\n+    assert orb.location[1] == pytest.approx(target_pos[1])\n+\n+def test_chaos_engine_fire_modes():\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    weapon = ChaosEngine()\n+    shooter.pickup_weapon(weapon)\n+    \n+    # Primary fire\n+    projs = shooter.shoot([200, 100])\n+    assert isinstance(projs[0], ChaosBolt)\n+    \n+    # Secondary fire\n+    weapon.last_secondary_time = 0 # Reset cooldown\n+    projs = weapon.secondary_fire(100, 100, 200, 200, shooter.id)\n+    assert isinstance(projs[0], AnomalyOrb)\n+    \n+    # Special fire\n+    weapon.last_special_time = 0 # Reset cooldown\n+    projs = weapon.special_fire(100, 100, 200, 200, shooter.id, is_holding=False)\n+    assert isinstance(projs[0], RealityResetProjectile)\n+\n+def test_chaos_bolt_collision_effects():\n+    # Since effects are random, we test that SOMETHING changed on the character\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    arena.add_character(shooter)\n+    arena.add_character(target)\n+    \n+    # Force a ChaosBolt collision\n+    bolt = ChaosBolt(200, 100, [1, 0], 25.0, 15.0, shooter.id)\n+    arena.projectiles.append(bolt)\n+    \n+    initial_health = target.health\n+    initial_pos = list(target.location)\n+    initial_scale = target.scale_ratio\n+    \n+    # Mock random to ensure we get a specific effect if we wanted, \n+    # but here we just check if any state changed\n+    # We'll run multiple times to hit different effects\n+    effects_triggered = set()\n+    \n+    for _ in range(20):\n+        target.health = 100\n+        target.location = [200, 100]\n+        target.scale_ratio = 1.0\n+        target.physics_inverted = False\n+        target.vertical_velocity = 0\n+        bolt = ChaosBolt(200, 100, [1, 0], 25.0, 15.0, shooter.id)\n+        arena.projectiles = [bolt]\n+        \n+        arena.handle_collisions(0.016)\n+        \n+        if target.location != [200, 100]: effects_triggered.add(\"swap\")\n+        if target.scale_ratio != 1.0: effects_triggered.add(\"scale\")\n+        if getattr(target, 'physics_inverted', False): effects_triggered.add(\"physics\")\n+        if target.vertical_velocity > 0: effects_triggered.add(\"launch\")\n+        \n+        if len(effects_triggered) >= 1: break # We saw at least one effect\n+\n+    assert target.health < initial_health\n+    assert len(effects_triggered) > 0, \"At least one chaos effect should have triggered\"\n+\n+def test_anomaly_orb_spawning_integration():\n+    arena = Arena(800, 600)\n+    orb = AnomalyOrb(100, 100, [100, 100], \"owner\") # Already at target\n+    orb.active = False # Signal it reached target\n+    orb.update(0.016) # Ensure state is consistent\n+    arena.projectiles.append(orb)\n+    \n+    arena.handle_collisions(0.016)\n+    \n+    # Check if a persistent projectile was spawned\n+    found_persistent = False\n+    for p in arena.projectiles:\n+        if isinstance(p, (BlackHoleProjectile, TornadoProjectile, StormCloud)):\n+            found_persistent = True\n+            break\n+    \n+    assert found_persistent, \"AnomalyOrb should spawn a persistent projectile upon reaching target\"\n+\n+def test_reality_reset_shuffle():\n+    arena = Arena(800, 600)\n+    char1 = Character(\"C1\", \"\", \"\", [100, 100])\n+    char2 = Character(\"C2\", \"\", \"\", [200, 200])\n+    arena.add_character(char1)\n+    arena.add_character(char2)\n+    \n+    # Add a weapon pickup\n+    weapon = ChaosEngine([300, 300])\n+    arena.weapon_pickups.append(weapon)\n+    \n+    # Trigger Reality Reset\n+    reset_proj = RealityResetProjectile(\"owner\")\n+    arena.projectiles.append(reset_proj)\n+    reset_proj.active = False # Trigger effect immediately on next collision check\n+    \n+    # Record initial positions\n+    initial_pos1 = list(char1.location)\n+    initial_pos2 = list(char2.location)\n+    initial_weapon_pos = list(weapon.location)\n+    \n+    # Shuffle is random, but we check if positions were swapped or moved\n+    # We run it a few times to be sure\n+    moved = False\n+    # Shuffle results might coincidentally match initial positions, but very unlikely for 3 entities.\n+    # We already added the proj and set active=False, just run one collision check.\n+    arena.handle_collisions(0.016)\n+    \n+    if (char1.location != initial_pos1 or \n+        char2.location != initial_pos2 or \n+        weapon.location != initial_weapon_pos):\n+        moved = True\n+        \n+    assert moved, \"Reality Reset should shuffle character/weapon locations\"\n+\n+def test_chaos_timer_countdown_integration():\n+    arena = Arena(800, 600)\n+    char = Character(\"C\", \"\", \"\", [100, 100])\n+    arena.add_character(char)\n+    \n+    char.physics_inverted = True\n+    char.chaos_timer = 1.0\n+    \n+    # Update arena\n+    arena.handle_collisions(0.5)\n+    assert char.chaos_timer == 0.5\n+    assert char.physics_inverted is True\n+    \n+    arena.handle_collisions(0.6)\n+    assert char.chaos_timer <= 0\n+    assert char.physics_inverted is False\n+\n+def test_chaos_engine_registration():\n+    from GameFolder.setup import setup_battle_arena\n+    arena = setup_battle_arena()\n+    \n+    assert \"The Chaos Engine\" in arena.lootpool\n+    # Check if one was spawned (as per setup.py)\n+    found = any(isinstance(w, ChaosEngine) for w in arena.weapon_pickups)\n+    assert found"
    },
    {
      "path": "GameFolder/weapons/CatRainGun.py",
      "diff": "--- a/GameFolder/weapons/CatRainGun.py\n+++ b/GameFolder/weapons/CatRainGun.py\n@@ -0,0 +1,18 @@\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.CatProjectiles import CatCloud\n+\n+class CatRainGun(Weapon):\n+    def __init__(self, location=None):\n+        # Name, damage (applied by spawned cats), cooldown, speed, location\n+        # Damage here is representative, actual damage depends on FallingCat.\n+        # Cooldown 5.0s as requested.\n+        super().__init__(\"Cat Rain Gun\", 5, 5.0, 12, location)\n+        self.color = (255, 165, 0)  # Orange like a ginger cat\n+\n+    def shoot(self, owner_x, owner_y, target_x, target_y, owner_id):\n+        \"\"\"\n+        Shoots a CatCloud projectile targeting the target location.\n+        \"\"\"\n+        target_pos = [target_x, target_y]\n+        # Create the CatCloud at the owner's position, heading to target_pos\n+        return CatCloud(owner_x, owner_y, target_pos, owner_id)"
    },
    {
      "path": "GameFolder/weapons/ChaosEngine.py",
      "diff": "--- a/GameFolder/weapons/ChaosEngine.py\n+++ b/GameFolder/weapons/ChaosEngine.py\n@@ -0,0 +1,117 @@\n+import pygame\n+import time\n+import math\n+import colorsys\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class RealityResetProjectile(Projectile):\n+    \"\"\"\n+    A special projectile that immediately deactivates and signals the Arena \n+    to perform a 'Reality Reset' (shuffle characters and items).\n+    \"\"\"\n+    def __init__(self, owner_id: str):\n+        # Spawn at 0,0 since it's just a signal\n+        super().__init__(0, 0, [0, 0], 0, 0, owner_id)\n+        self.active = False\n+        self.is_reality_reset = True # Marker for the Arena\n+\n+class ChaosEngine(Weapon):\n+    def __init__(self, location: list[float, float] = None):\n+        # Name: \"The Chaos Engine\"\n+        # Cooldown: Primary is handled by 'cooldown' param.\n+        super().__init__(name=\"The Chaos Engine\", damage=15, cooldown=0.4, projectile_speed=25.0, location=location)\n+        \n+        self.secondary_cooldown = 4.0\n+        self.special_cooldown = 12.0\n+        self.last_secondary_time = 0.0\n+        self.last_special_time = 0.0\n+        \n+        # Visual properties\n+        self.width = 45\n+        self.height = 30\n+        self.frequency = 3.0 # For color shifting\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"Primary fire: ChaosBolt\"\"\"\n+        if not self.can_shoot():\n+            return None\n+            \n+        self.last_shot_time = time.time()\n+        \n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist > 0 else [1, 0]\n+        \n+        return [ChaosBolt(owner_x, owner_y, direction, self.projectile_speed, self.damage, owner_id)]\n+\n+    def secondary_fire(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"Secondary fire: AnomalyOrb. Cooldown: 4.0s\"\"\"\n+        now = time.time()\n+        if (now - self.last_secondary_time) < self.secondary_cooldown:\n+            return None\n+            \n+        self.last_secondary_time = now\n+        return [AnomalyOrb(owner_x, owner_y, [target_x, target_y], owner_id)]\n+\n+    def special_fire(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str, is_holding: bool):\n+        \"\"\"Special fire: Reality Reset. Cooldown: 12.0s\"\"\"\n+        if is_holding: # Only trigger on initial press\n+            return None\n+            \n+        now = time.time()\n+        if (now - self.last_special_time) < self.special_cooldown:\n+            return None\n+            \n+        self.last_special_time = now\n+        return [RealityResetProjectile(owner_id)]\n+\n+    def update_color(self):\n+        \"\"\"Calculates the flickering/shifting rainbow color.\"\"\"\n+        hue = (time.time() * self.frequency) % 1.0\n+        rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)\n+        self.color = (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"Draw with a flickering/shifting rainbow color.\"\"\"\n+        if self.is_equipped:\n+            return\n+            \n+        self.update_color()\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        weapon_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        \n+        # Draw shifting glow\n+        glow_size = 5 + int(math.sin(time.time() * 10) * 3)\n+        glow_rect = weapon_rect.inflate(glow_size, glow_size)\n+        pygame.draw.rect(screen, self.color, glow_rect, 2)\n+        \n+        # Draw main body\n+        pygame.draw.rect(screen, self.color, weapon_rect)\n+        \n+        # Inner \"glitch\" core\n+        inner_color = (255 - self.color[0], 255 - self.color[1], 255 - self.color[2])\n+        inner_rect = weapon_rect.inflate(-10, -10)\n+        pygame.draw.rect(screen, inner_color, inner_rect)\n+        \n+        # Border\n+        pygame.draw.rect(screen, (255, 255, 255), weapon_rect, 2)\n+        \n+        # Name text with background\n+        font = pygame.font.Font(None, 20)\n+        text = font.render(self.name, True, (255, 255, 255))\n+        text_rect = text.get_rect(center=(self.location[0] + self.width/2, py_y - 15))\n+        \n+        bg_rect = text_rect.inflate(8, 4)\n+        pygame.draw.rect(screen, (0, 0, 0), bg_rect)\n+        pygame.draw.rect(screen, (255, 255, 255), bg_rect, 1)\n+        \n+        # Text flickering shadow\n+        if int(time.time() * 20) % 2 == 0:\n+            shadow = font.render(self.name, True, self.color)\n+            screen.blit(shadow, (text_rect.x + 2, text_rect.y + 1))\n+            \n+        screen.blit(text, text_rect)\n"
    }
  ]
}