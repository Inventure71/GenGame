{"name_of_backup": "20260104161653_GameFolder", "changes": [{"path": "GameFolder/projectiles/KamehamehaProjectile.py", "diff": "--- a/GameFolder/projectiles/KamehamehaProjectile.py\n+++ b/GameFolder/projectiles/KamehamehaProjectile.py\n@@ -0,0 +1,105 @@\n+import pygame\n+import math\n+import random\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class KamehamehaProjectile(Projectile):\n+    def __init__(self, x: float, y: float, direction: list, owner_id: str, damage: float):\n+        # Initialize with speed 0 because it's anchored to owner or behaves like a beam\n+        super().__init__(x, y, direction, 0, damage, owner_id, width=40, height=40)\n+        self.state = 'CHARGING'\n+        self.timer = 0.0\n+        self.charge_duration = 1.2\n+        self.fire_duration = 1.5\n+        self.beam_length = 2000 # Large enough to cross arena\n+        self.pulse_timer = 0.0\n+        \n+        # For visual effects\n+        self.charge_particles = []\n+        for _ in range(12):\n+            self.charge_particles.append({\n+                'angle': random.uniform(0, math.pi * 2),\n+                'dist': random.uniform(30, 60),\n+                'speed': random.uniform(1, 3)\n+            })\n+\n+    def update(self, delta_time: float):\n+        self.timer += delta_time\n+        self.pulse_timer += delta_time\n+        \n+        if self.state == 'CHARGING':\n+            if self.timer >= self.charge_duration:\n+                self.state = 'FIRING'\n+                self.timer = 0.0\n+            \n+            # Update charge particles\n+            for p in self.charge_particles:\n+                p['dist'] -= p['speed'] * (delta_time * 60)\n+                if p['dist'] < 5:\n+                    p['dist'] = random.uniform(40, 70)\n+                    p['angle'] = random.uniform(0, math.pi * 2)\n+                    \n+        elif self.state == 'FIRING':\n+            if self.timer >= self.fire_duration:\n+                self.active = False\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1]\n+        py_x = self.location[0]\n+\n+        if self.state == 'CHARGING':\n+            # Pulsing blue orb\n+            pulse = (math.sin(self.pulse_timer * 15) + 1) * 0.5\n+            radius = 15 + pulse * 10\n+            \n+            # Outer Glow\n+            pygame.draw.circle(screen, (0, 100, 255), (int(py_x), int(py_y)), int(radius + 5), 2)\n+            # Core\n+            pygame.draw.circle(screen, (200, 230, 255), (int(py_x), int(py_y)), int(radius))\n+            \n+            # Draw gathering particles\n+            for p in self.charge_particles:\n+                px = py_x + math.cos(p['angle']) * p['dist']\n+                py = py_y + math.sin(p['angle']) * p['dist']\n+                pygame.draw.circle(screen, (100, 200, 255), (int(px), int(py)), 3)\n+\n+        elif self.state == 'FIRING':\n+            # Beam visual\n+            flicker = random.randint(-5, 5)\n+            beam_width = 60 + flicker\n+            \n+            # Calculate end point based on direction\n+            end_x = py_x + self.direction[0] * self.beam_length\n+            end_y = py_y - self.direction[1] * self.beam_length # y-up logic to y-down screen\n+            \n+            # Draw beam layers\n+            # 1. Outer Glow\n+            pygame.draw.line(screen, (0, 150, 255), (py_x, py_y), (end_x, end_y), int(beam_width + 20))\n+            # 2. Main Blue\n+            pygame.draw.line(screen, (100, 200, 255), (py_x, py_y), (end_x, end_y), int(beam_width))\n+            # 3. White Core\n+            pygame.draw.line(screen, (255, 255, 255), (py_x, py_y), (end_x, end_y), int(beam_width // 2))\n+            \n+            # Flickering Orbs along the beam\n+            for i in range(10):\n+                dist_ratio = ( (self.pulse_timer * 2 + i/10.0) % 1.0 )\n+                bx = py_x + self.direction[0] * self.beam_length * dist_ratio\n+                by = py_y - self.direction[1] * self.beam_length * dist_ratio\n+                pygame.draw.circle(screen, (255, 255, 255), (int(bx), int(by)), random.randint(5, 15))\n+\n+            # Start Orb\n+            pygame.draw.circle(screen, (200, 230, 255), (int(py_x), int(py_y)), int(beam_width // 1.2))\n+\n+    def get_rect(self) -> pygame.Rect:\n+        # For the beam, the 'rect' is tricky. \n+        # Usually collisions are handled by the arena for beams, \n+        # but we'll return a representative rect of the firing point for now.\n+        if self.state == 'FIRING':\n+            # Large bounding box for simple logic or specific beam collision logic in Arena\n+            return pygame.Rect(self.location[0] - 50, self.location[1] - 50, 100, 100)\n+        else:\n+            return pygame.Rect(self.location[0] - 20, self.location[1] - 20, 40, 40)"}, {"path": "GameFolder/weapons/KamehamehaGun.py", "diff": "--- a/GameFolder/weapons/KamehamehaGun.py\n+++ b/GameFolder/weapons/KamehamehaGun.py\n@@ -0,0 +1,78 @@\n+import pygame\n+import math\n+import time\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n+\n+class KamehamehaGun(Weapon):\n+    def __init__(self, location: [float, float] = None):\n+        # Long cooldown (5 seconds) and high base damage (50)\n+        # Note: Actual damage is applied per-frame in the arena logic during the FIRING state.\n+        super().__init__(\n+            name=\"Kamehameha\",\n+            damage=50.0,\n+            cooldown=5.0,\n+            projectile_speed=0.0,  # The beam doesn't 'travel' in a traditional sense\n+            location=location\n+        )\n+        self.color = (0, 191, 255)  # Deep Sky Blue\n+        self.width = 40\n+        self.height = 30\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"\n+        Returns a KamehamehaProjectile which handles its own state (CHARGING then FIRING).\n+        \"\"\"\n+        if not self.can_shoot():\n+            return None\n+\n+        self.last_shot_time = time.time()\n+\n+        # Calculate direction\n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        if dist == 0:\n+            direction = [1, 0]\n+        else:\n+            direction = [dx / dist, dy / dist]\n+\n+        # Create the projectile\n+        projectile = KamehamehaProjectile(\n+            x=owner_x,\n+            y=owner_y,\n+            direction=direction,\n+            damage=self.damage,\n+            owner_id=owner_id\n+        )\n+        \n+        # Most weapons return a list of projectiles\n+        return [projectile]\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"\n+        Custom draw method for the weapon pickup: looks like a glowing energy orb/gauntlet.\n+        \"\"\"\n+        if self.is_equipped:\n+            return\n+\n+        # World (Y-up) to Screen (Y-down)\n+        py_y = arena_height - self.location[1] - self.height\n+        center_x = self.location[0] + self.width // 2\n+        center_y = py_y + self.height // 2\n+\n+        # Animated pulse effect\n+        pulse = (math.sin(time.time() * 5) + 1) / 2  # 0 to 1\n+        glow_radius = 15 + (10 * pulse)\n+        \n+        # Draw glow\n+        glow_surf = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)\n+        pygame.draw.circle(glow_surf, (100, 200, 255, 100), (int(glow_radius), int(glow_radius)), int(glow_radius))\n+        screen.blit(glow_surf, (center_x - glow_radius, center_y - glow_radius))\n+\n+        # Draw core orb\n+        pygame.draw.circle(screen, (255, 255, 255), (int(center_x), int(center_y)), 8)\n+        pygame.draw.circle(screen, (0, 150, 255), (int(center_x), int(center_y)), 10, 2)\n+\n+        # Draw name\n+        super().draw(screen, arena_height)"}, {"path": "GameFolder/arenas/GAME_arena.py", "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,8 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n import pygame\n import random\n import math\n@@ -26,6 +28,7 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"KamehamehaGun\", KamehamehaGun)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +50,7 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, KamehamehaProjectile)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -227,6 +230,56 @@\n                     if char.location[0] < beam_x_max and char.location[0] + char_w > beam_x_min:\n                         char.take_damage(proj.damage * delta_time)\n             \n+            elif isinstance(proj, KamehamehaProjectile):\n+                # Find owner to anchor and apply recoil\n+                owner = next((c for c in self.characters if c.id == proj.owner_id), None)\n+                if owner and owner.is_alive:\n+                    # Anchor to owner center\n+                    owner_center_x = owner.location[0] + (owner.width * owner.scale_ratio) / 2\n+                    owner_center_y = owner.location[1] + (owner.height * owner.scale_ratio) / 2\n+                    proj.location = [owner_center_x, owner_center_y]\n+                    \n+                    if proj.state == 'FIRING':\n+                        # Apply recoil to owner (push away from beam direction)\n+                        recoil_strength = 250.0 # units per second\n+                        owner.location[0] -= proj.direction[0] * recoil_strength * delta_time\n+                        owner.location[1] -= proj.direction[1] * recoil_strength * delta_time\n+                        \n+                        # Beam Collision Logic\n+                        for char in self.characters:\n+                            if not char.is_alive or char.id == proj.owner_id:\n+                                continue\n+                            \n+                            # Character center\n+                            c_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+                            c_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+                            \n+                            # Vector from beam start to character\n+                            dx = c_center_x - proj.location[0]\n+                            dy = c_center_y - proj.location[1]\n+                            \n+                            # Projection of (dx, dy) onto beam direction\n+                            dot = dx * proj.direction[0] + dy * proj.direction[1]\n+                            \n+                            # If character is in front of the beam and within beam length\n+                            if 0 <= dot <= proj.beam_length:\n+                                # Closest point on the line\n+                                closest_x = proj.location[0] + proj.direction[0] * dot\n+                                closest_y = proj.location[1] + proj.direction[1] * dot\n+                                \n+                                # Distance from character center to closest point\n+                                dist_sq = (c_center_x - closest_x)**2 + (c_center_y - closest_y)**2\n+                                hit_radius = 45 # Beam radius approx\n+                                \n+                                if dist_sq < hit_radius**2:\n+                                    # Apply continuous damage\n+                                    char.take_damage(proj.damage * delta_time)\n+                                    \n+                                    # Apply knockback (in direction of beam)\n+                                    knockback_force = 400.0\n+                                    char.location[0] += proj.direction[0] * knockback_force * delta_time\n+                                    char.location[1] += proj.direction[1] * knockback_force * delta_time\n+\n             # Put persistent projectile back into active list\n             if proj.active:\n                 self.projectiles.append(proj)\n"}, {"path": "GameFolder/setup.py", "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,7 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +45,9 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"Kamehameha Gun\", KamehamehaGun)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(KamehamehaGun([600, 400]))\n     \n     return arena"}, {"path": "GameFolder/tests/kamehameha_tests.py", "diff": "--- a/GameFolder/tests/kamehameha_tests.py\n+++ b/GameFolder/tests/kamehameha_tests.py\n@@ -0,0 +1,203 @@\n+\"\"\"\n+Tests for Kamehameha Weapon and Projectile\n+\"\"\"\n+import pytest\n+import math\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n+from GameFolder.arenas.GAME_arena import Arena\n+\n+def test_kamehameha_gun_creation():\n+    \"\"\"Test that the Kamehameha gun initializes with correct values.\"\"\"\n+    gun = KamehamehaGun(location=[100, 100])\n+    assert gun.name == \"Kamehameha\"\n+    assert gun.damage == 50.0\n+    assert gun.cooldown == 5.0\n+    assert gun.location == [100, 100]\n+\n+def test_kamehameha_gun_shooting():\n+    \"\"\"Test that shooting returns a KamehamehaProjectile and triggers cooldown.\"\"\"\n+    gun = KamehamehaGun()\n+    # Initial shot should succeed\n+    projs = gun.shoot(owner_x=100, owner_y=100, target_x=200, target_y=100, owner_id=\"test_owner\")\n+    assert projs is not None\n+    assert len(projs) == 1\n+    assert isinstance(projs[0], KamehamehaProjectile)\n+    assert projs[0].owner_id == \"test_owner\"\n+    \n+    # Immediate second shot should fail due to cooldown\n+    projs2 = gun.shoot(owner_x=100, owner_y=100, target_x=200, target_y=100, owner_id=\"test_owner\")\n+    assert projs2 is None\n+\n+def test_kamehameha_projectile_states():\n+    \"\"\"Test that the Kamehameha projectile transitions through its states correctly.\"\"\"\n+    proj = KamehamehaProjectile(x=100, y=100, direction=[1, 0], owner_id=\"owner\", damage=50.0)\n+    assert proj.state == 'CHARGING'\n+    assert proj.active\n+    \n+    # Update to nearly finish charging\n+    dt = 0.1\n+    total_time = 0.0\n+    while total_time < proj.charge_duration - 0.05:\n+        proj.update(dt)\n+        total_time += dt\n+        assert proj.state == 'CHARGING'\n+    \n+    # One more update to transition to FIRING\n+    proj.update(0.1)\n+    assert proj.state == 'FIRING'\n+    \n+    # Update through FIRING duration\n+    total_firing_time = 0.0\n+    while total_firing_time < proj.fire_duration - 0.05:\n+        proj.update(dt)\n+        total_firing_time += dt\n+        assert proj.state == 'FIRING'\n+        assert proj.active\n+        \n+    # Final update to deactivate\n+    proj.update(0.1)\n+    assert not proj.active\n+\n+def test_kamehameha_integration_anchoring_and_recoil():\n+    \"\"\"Test anchoring to owner and recoil application in the Arena.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    char = Character(\"Shooter\", \"char1\", \"char1\", [500, 500])\n+    arena.characters = [char]\n+    \n+    # Give shooter the gun\n+    gun = KamehamehaGun()\n+    char.weapon = gun\n+    \n+    # Shoot right\n+    projs = char.shoot([600, 500])\n+    arena.projectiles.extend(projs)\n+    proj = projs[0]\n+    \n+    # 1. CHARGING State - Anchoring check\n+    char.location = [550, 550] # Move character during charging\n+    arena.handle_collisions(0.1)\n+    \n+    # Projectile should follow character center\n+    char_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+    char_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+    assert proj.location[0] == char_center_x\n+    assert proj.location[1] == char_center_y\n+    \n+    # No recoil during charging\n+    assert char.location == [550, 550]\n+    \n+    # 2. Transition to FIRING\n+    for _ in range(15): # Step past 1.2s charge\n+        arena.handle_collisions(0.1)\n+    \n+    assert proj.state == 'FIRING'\n+    \n+    # 3. FIRING State - Recoil check\n+    initial_loc = list(char.location)\n+    arena.handle_collisions(0.1)\n+    \n+    # Character should be pushed LEFT if shooting RIGHT ([1, 0])\n+    # recoil_strength is 250 units/s. In 0.1s, should move 25 units.\n+    assert char.location[0] < initial_loc[0]\n+    assert math.isclose(char.location[0], initial_loc[0] - 25.0, abs_tol=0.1)\n+\n+def test_kamehameha_integration_beam_collision():\n+    \"\"\"Test beam collision detection and damage application in the Arena.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    shooter = Character(\"Shooter\", \"char1\", \"char1\", [100, 500])\n+    target = Character(\"Target\", \"char2\", \"char2\", [300, 500])\n+    arena.characters = [shooter, target]\n+    \n+    # Shoot right at target\n+    gun = KamehamehaGun()\n+    shooter.weapon = gun\n+    projs = shooter.shoot([400, 500])\n+    arena.projectiles.extend(projs)\n+    proj = projs[0]\n+    \n+    # Skip charging\n+    for _ in range(15):\n+        arena.handle_collisions(0.1)\n+    \n+    assert proj.state == 'FIRING'\n+    \n+    # Check damage and knockback\n+    initial_hp = target.hp\n+    initial_x = target.location[0]\n+    \n+    arena.handle_collisions(0.1)\n+    \n+    assert target.hp < initial_hp\n+    assert target.location[0] > initial_x # Knockback to the right\n+    \n+    # Test target out of beam radius (above)\n+    target.location = [300, 700] \n+    target.hp = 100\n+    initial_x = target.location[0]\n+    arena.handle_collisions(0.1)\n+    \n+    assert target.hp == 100 # No damage\n+    assert target.location[0] == initial_x # No knockback\n+\n+def test_kamehameha_edge_cases():\n+    \"\"\"Test firing from boundaries and corners.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    gun = KamehamehaGun()\n+    \n+    # Corner: Bottom-Left shooting Top-Right\n+    projs = gun.shoot(0, 0, 1000, 1000, \"owner\")\n+    proj = projs[0]\n+    assert math.isclose(proj.direction[0], 0.707, abs_tol=0.01)\n+    assert math.isclose(proj.direction[1], 0.707, abs_tol=0.01)\n+    \n+    # Boundary: Top edge shooting down\n+    projs = gun.shoot(500, 1000, 500, 0, \"owner\")\n+    proj = projs[0]\n+    assert proj.direction == [0, -1]\n+\n+def test_kamehameha_lootpool_registration():\n+    \"\"\"Test that KamehamehaGun is registered in the arena's lootpool.\"\"\"\n+    from GameFolder.setup import setup_battle_arena\n+    arena = setup_battle_arena()\n+    assert \"Kamehameha Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Kamehameha Gun\"] == KamehamehaGun\n+\n+def test_kamehameha_owner_death():\n+    \"\"\"Test that projectile continues if owner dies (or behavior depends on implementation).\n+    In current Arena implementation, it checks `if owner and owner.is_alive`.\n+    If owner is dead, anchoring and recoil stop.\n+    \"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    shooter = Character(\"Shooter\", \"char1\", \"char1\", [100, 500])\n+    arena.characters = [shooter]\n+    proj = KamehamehaProjectile(100, 500, [1, 0], shooter.id, 50.0)\n+    arena.projectiles.append(proj)\n+    \n+    shooter.hp = 0 # Kill shooter\n+    arena.handle_collisions(0.1)\n+    \n+    # Should not crash, and proj location should not have changed if it didn't find owner\n+    assert proj.location == [100, 500]\n+\n+def test_kamehameha_origin_scenarios():\n+    \"\"\"Test firing from specific origins requested in instructions.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    gun = KamehamehaGun()\n+    \n+    # 1. Center\n+    projs = gun.shoot(500, 500, 600, 500, \"owner\")\n+    assert projs[0].location == [500, 500]\n+    \n+    # 2. Close to another character\n+    shooter = Character(\"S\", \"s\", \"s\", [500, 500])\n+    target = Character(\"T\", \"t\", \"t\", [510, 500]) # 10 units away\n+    arena.characters = [shooter, target]\n+    shooter.weapon = gun\n+    projs = shooter.shoot([510, 500])\n+    arena.projectiles.extend(projs)\n+    \n+    # Move to firing state\n+    for _ in range(15): arena.handle_collisions(0.1)\n+    assert target.hp < 100, \"Target very close to shooter should be hit immediately by beam\""}]}