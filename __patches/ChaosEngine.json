{"name_of_backup": "20260104161653_GameFolder", "changes": [{"path": "GameFolder/projectiles/ChaosProjectiles.py", "diff": "--- a/GameFolder/projectiles/ChaosProjectiles.py\n+++ b/GameFolder/projectiles/ChaosProjectiles.py\n@@ -0,0 +1,61 @@\n+import pygame\n+import math\n+import time\n+import colorsys\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class ChaosBolt(Projectile):\n+    def __init__(self, x: float, y: float, direction: list[float, float], speed: float, damage: float, owner_id: str):\n+        # Faster than normal projectiles (multiplier applied here or in weapon)\n+        super().__init__(x, y, direction, speed, damage, owner_id, width=12, height=12)\n+        self.frequency = 2.0  # Speed of color shifting\n+\n+    def update(self, delta_time: float):\n+        super().update(delta_time)\n+        # Update color with rainbow-shifting HSL\n+        hue = (time.time() * self.frequency) % 1.0\n+        rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)\n+        self.color = (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        \n+        # Draw with a slight trail or glow effect using the rainbow color\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+        # Glitchy inner core\n+        inner_color = (255 - self.color[0], 255 - self.color[1], 255 - self.color[2])\n+        inner_rect = py_rect.inflate(-4, -4)\n+        pygame.draw.ellipse(screen, inner_color, inner_rect)\n+\n+class AnomalyOrb(Projectile):\n+    def __init__(self, x: float, y: float, target_pos: list[float, float], owner_id: str):\n+        # Travels towards target_pos\n+        dx = target_pos[0] - x\n+        dy = target_pos[1] - y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist > 0 else [0, 0]\n+        \n+        super().__init__(x, y, direction, speed=8, damage=0, owner_id=owner_id, width=20, height=20)\n+        self.target_pos = target_pos\n+        self.color = (150, 0, 200) # Purple/Anomaly color\n+\n+    def update(self, delta_time: float):\n+        dx = self.target_pos[0] - self.location[0]\n+        dy = self.target_pos[1] - self.location[1]\n+        dist = math.hypot(dx, dy)\n+        \n+        move_dist = self.speed * (delta_time * 60)\n+        \n+        if dist <= move_dist:\n+            self.location[0] = self.target_pos[0]\n+            self.location[1] = self.target_pos[1]\n+            # When it reaches target_pos, it sets active = False \n+            # Arena should spawn random persistent projectile here\n+            self.active = False\n+        else:\n+            self.location[0] += self.direction[0] * move_dist\n+            self.location[1] += self.direction[1] * move_dist"}, {"path": "GameFolder/weapons/ChaosEngine.py", "diff": "--- a/GameFolder/weapons/ChaosEngine.py\n+++ b/GameFolder/weapons/ChaosEngine.py\n@@ -0,0 +1,117 @@\n+import pygame\n+import time\n+import math\n+import colorsys\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class RealityResetProjectile(Projectile):\n+    \"\"\"\n+    A special projectile that immediately deactivates and signals the Arena \n+    to perform a 'Reality Reset' (shuffle characters and items).\n+    \"\"\"\n+    def __init__(self, owner_id: str):\n+        # Spawn at 0,0 since it's just a signal\n+        super().__init__(0, 0, [0, 0], 0, 0, owner_id)\n+        self.active = False\n+        self.is_reality_reset = True # Marker for the Arena\n+\n+class ChaosEngine(Weapon):\n+    def __init__(self, location: list[float, float] = None):\n+        # Name: \"The Chaos Engine\"\n+        # Cooldown: Primary is handled by 'cooldown' param.\n+        super().__init__(name=\"The Chaos Engine\", damage=15, cooldown=0.4, projectile_speed=25.0, location=location)\n+        \n+        self.secondary_cooldown = 4.0\n+        self.special_cooldown = 12.0\n+        self.last_secondary_time = 0.0\n+        self.last_special_time = 0.0\n+        \n+        # Visual properties\n+        self.width = 45\n+        self.height = 30\n+        self.frequency = 3.0 # For color shifting\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"Primary fire: ChaosBolt\"\"\"\n+        if not self.can_shoot():\n+            return None\n+            \n+        self.last_shot_time = time.time()\n+        \n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist > 0 else [1, 0]\n+        \n+        return [ChaosBolt(owner_x, owner_y, direction, self.projectile_speed, self.damage, owner_id)]\n+\n+    def secondary_fire(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"Secondary fire: AnomalyOrb. Cooldown: 4.0s\"\"\"\n+        now = time.time()\n+        if (now - self.last_secondary_time) < self.secondary_cooldown:\n+            return None\n+            \n+        self.last_secondary_time = now\n+        return [AnomalyOrb(owner_x, owner_y, [target_x, target_y], owner_id)]\n+\n+    def special_fire(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str, is_holding: bool):\n+        \"\"\"Special fire: Reality Reset. Cooldown: 12.0s\"\"\"\n+        if is_holding: # Only trigger on initial press\n+            return None\n+            \n+        now = time.time()\n+        if (now - self.last_special_time) < self.special_cooldown:\n+            return None\n+            \n+        self.last_special_time = now\n+        return [RealityResetProjectile(owner_id)]\n+\n+    def update_color(self):\n+        \"\"\"Calculates the flickering/shifting rainbow color.\"\"\"\n+        hue = (time.time() * self.frequency) % 1.0\n+        rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)\n+        self.color = (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"Draw with a flickering/shifting rainbow color.\"\"\"\n+        if self.is_equipped:\n+            return\n+            \n+        self.update_color()\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        weapon_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        \n+        # Draw shifting glow\n+        glow_size = 5 + int(math.sin(time.time() * 10) * 3)\n+        glow_rect = weapon_rect.inflate(glow_size, glow_size)\n+        pygame.draw.rect(screen, self.color, glow_rect, 2)\n+        \n+        # Draw main body\n+        pygame.draw.rect(screen, self.color, weapon_rect)\n+        \n+        # Inner \"glitch\" core\n+        inner_color = (255 - self.color[0], 255 - self.color[1], 255 - self.color[2])\n+        inner_rect = weapon_rect.inflate(-10, -10)\n+        pygame.draw.rect(screen, inner_color, inner_rect)\n+        \n+        # Border\n+        pygame.draw.rect(screen, (255, 255, 255), weapon_rect, 2)\n+        \n+        # Name text with background\n+        font = pygame.font.Font(None, 20)\n+        text = font.render(self.name, True, (255, 255, 255))\n+        text_rect = text.get_rect(center=(self.location[0] + self.width/2, py_y - 15))\n+        \n+        bg_rect = text_rect.inflate(8, 4)\n+        pygame.draw.rect(screen, (0, 0, 0), bg_rect)\n+        pygame.draw.rect(screen, (255, 255, 255), bg_rect, 1)\n+        \n+        # Text flickering shadow\n+        if int(time.time() * 20) % 2 == 0:\n+            shadow = font.render(self.name, True, self.color)\n+            screen.blit(shadow, (text_rect.x + 2, text_rect.y + 1))\n+            \n+        screen.blit(text, text_rect)\n"}, {"path": "GameFolder/arenas/GAME_arena.py", "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,8 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.ChaosEngine import ChaosEngine, RealityResetProjectile\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n import pygame\n import random\n import math\n@@ -26,6 +28,7 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"ChaosEngine\", ChaosEngine)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +50,7 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, ChaosBolt, AnomalyOrb, RealityResetProjectile)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -61,23 +64,75 @@\n         \n         # Manually handle special/persistent projectiles\n         for proj in special_projs:\n-            # Special case for OrbitalStrikeMarker: check transition even if inactive at start of loop\n-            if isinstance(proj, OrbitalStrikeMarker) and not proj.active:\n+            # Update if active\n+            if proj.active:\n+                proj.update(delta_time)\n+\n+            # Post-update check: Handle transitions for special projectiles that just became inactive\n+            if not proj.active and isinstance(proj, OrbitalStrikeMarker):\n                 blast = OrbitalBlast(proj.location[0], proj.owner_id)\n                 if blast not in self.projectiles:\n                     self.projectiles.append(blast)\n-                continue\n+                continue # Don't re-add marker to active projectiles\n+\n+            if proj.active and isinstance(proj, ChaosBolt):\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id: continue\n+                    \n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    \n+                    proj_rect = pygame.Rect(proj.location[0], self.height - proj.location[1] - proj.height, proj.width, proj.height)\n+                    \n+                    if char_rect.colliderect(proj_rect):\n+                        char.take_damage(proj.damage)\n+                        proj.active = False\n+                        \n+                        # Chaos Bolt Hit Effect\n+                        effect = random.randint(0, 3)\n+                        if effect == 0: # Swap locations\n+                            owner = next((c for c in self.characters if c.id == proj.owner_id), None)\n+                            if owner:\n+                                owner.location, char.location = list(char.location), list(owner.location)\n+                        elif effect == 1: # Random scale\n+                            char.scale_ratio = random.uniform(0.5, 2.0)\n+                        elif effect == 2: # Inverted physics\n+                            char.physics_inverted = True\n+                            if not hasattr(char, 'chaos_timer'): char.chaos_timer = 0\n+                            char.chaos_timer = 3.0\n+                        elif effect == 3: # Launch upwards\n+                            char.vertical_velocity = 25.0\n+\n+            elif not proj.active and isinstance(proj, AnomalyOrb):\n+                # Reached target or collided\n+                spawn_type = random.choice([BlackHoleProjectile, TornadoProjectile, StormCloud])\n+                new_proj = None\n+                if spawn_type == BlackHoleProjectile:\n+                    new_proj = BlackHoleProjectile(proj.location[0], proj.location[1], proj.location[0], proj.location[1], proj.owner_id)\n+                elif spawn_type == TornadoProjectile:\n+                    new_proj = TornadoProjectile(proj.location[0], proj.location[1], [0, 1], 0.5, proj.owner_id)\n+                elif spawn_type == StormCloud:\n+                    new_proj = StormCloud(proj.location[0], proj.location[1], proj.location, proj.owner_id)\n+                \n+                if new_proj:\n+                    self.projectiles.append(new_proj)\n+                continue # Don't re-add orb\n+\n+            elif not proj.active and isinstance(proj, RealityResetProjectile):\n+                # Reality Reset: Shuffle characters and weapon pickups\n+                spawn_points = [list(c.location) for c in self.characters]\n+                spawn_points.extend([list(w.location) for w in self.weapon_pickups])\n+                random.shuffle(spawn_points)\n+                \n+                for char in self.characters:\n+                    if spawn_points:\n+                        char.location = spawn_points.pop()\n+                for weapon in self.weapon_pickups:\n+                    if spawn_points:\n+                        weapon.location = spawn_points.pop()\n+                continue # Don't re-add reset projectile\n \n             if not proj.active:\n-                continue\n-                \n-            proj.update(delta_time)\n-\n-            # Check if OrbitalStrikeMarker became inactive during update\n-            if isinstance(proj, OrbitalStrikeMarker) and not proj.active:\n-                blast = OrbitalBlast(proj.location[0], proj.owner_id)\n-                if blast not in self.projectiles:\n-                    self.projectiles.append(blast)\n                 continue\n \n             if isinstance(proj, StormCloud):\n@@ -236,6 +291,13 @@\n                 proj.location[1] < -200 or proj.location[1] > self.height + 200):\n                 if proj in self.projectiles:\n                     self.projectiles.remove(proj)\n+\n+        # Handle character chaos timer (inverted physics)\n+        for char in self.characters:\n+            if hasattr(char, 'chaos_timer') and char.chaos_timer > 0:\n+                char.chaos_timer -= delta_time\n+                if char.chaos_timer <= 0:\n+                    char.physics_inverted = False\n \n         for plat in self.platforms[1:]: # Skip floor\n             if not getattr(plat, 'being_pulled', False):\n"}, {"path": "GameFolder/setup.py", "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,7 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.ChaosEngine import ChaosEngine\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +45,9 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"The Chaos Engine\", ChaosEngine)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(ChaosEngine([600, 100]))\n     \n     return arena"}, {"path": "GameFolder/tests/test_chaos_engine.py", "diff": "--- a/GameFolder/tests/test_chaos_engine.py\n+++ b/GameFolder/tests/test_chaos_engine.py\n@@ -0,0 +1,188 @@\n+import pytest\n+import pygame\n+import time\n+import random\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.weapons.ChaosEngine import ChaosEngine, RealityResetProjectile\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.projectiles.BlackHoleProjectile import BlackHoleProjectile\n+from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n+from GameFolder.projectiles.GAME_projectile import StormCloud\n+\n+def test_chaos_engine_initialization():\n+    weapon = ChaosEngine([100, 100])\n+    assert weapon.name == \"The Chaos Engine\"\n+    assert weapon.damage == 15\n+    assert weapon.projectile_speed == 25.0\n+    assert weapon.secondary_cooldown == 4.0\n+    assert weapon.special_cooldown == 12.0\n+\n+def test_chaos_bolt_mechanics():\n+    shooter_id = \"shooter\"\n+    bolt = ChaosBolt(100, 100, [1, 0], 25.0, 15.0, shooter_id)\n+    \n+    # Test movement\n+    bolt.update(0.016)\n+    assert bolt.location[0] > 100\n+    \n+    # Test color update (rainbow shifting)\n+    initial_color = bolt.color\n+    time.sleep(0.1) # Ensure time passes for color shift\n+    bolt.update(0.016)\n+    assert bolt.color != initial_color\n+\n+def test_anomaly_orb_movement_and_deactivation():\n+    target_pos = [200, 200]\n+    orb = AnomalyOrb(100, 100, target_pos, \"owner\")\n+    \n+    # Simulate movement until it reaches target\n+    for _ in range(200):\n+        orb.update(0.016)\n+        if not orb.active:\n+            break\n+            \n+    assert orb.active is False\n+    assert orb.location[0] == pytest.approx(target_pos[0])\n+    assert orb.location[1] == pytest.approx(target_pos[1])\n+\n+def test_chaos_engine_fire_modes():\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    weapon = ChaosEngine()\n+    shooter.pickup_weapon(weapon)\n+    \n+    # Primary fire\n+    projs = shooter.shoot([200, 100])\n+    assert isinstance(projs[0], ChaosBolt)\n+    \n+    # Secondary fire\n+    weapon.last_secondary_time = 0 # Reset cooldown\n+    projs = weapon.secondary_fire(100, 100, 200, 200, shooter.id)\n+    assert isinstance(projs[0], AnomalyOrb)\n+    \n+    # Special fire\n+    weapon.last_special_time = 0 # Reset cooldown\n+    projs = weapon.special_fire(100, 100, 200, 200, shooter.id, is_holding=False)\n+    assert isinstance(projs[0], RealityResetProjectile)\n+\n+def test_chaos_bolt_collision_effects():\n+    # Since effects are random, we test that SOMETHING changed on the character\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    arena.add_character(shooter)\n+    arena.add_character(target)\n+    \n+    # Force a ChaosBolt collision\n+    bolt = ChaosBolt(200, 100, [1, 0], 25.0, 15.0, shooter.id)\n+    arena.projectiles.append(bolt)\n+    \n+    initial_health = target.health\n+    initial_pos = list(target.location)\n+    initial_scale = target.scale_ratio\n+    \n+    # Mock random to ensure we get a specific effect if we wanted, \n+    # but here we just check if any state changed\n+    # We'll run multiple times to hit different effects\n+    effects_triggered = set()\n+    \n+    for _ in range(20):\n+        target.health = 100\n+        target.location = [200, 100]\n+        target.scale_ratio = 1.0\n+        target.physics_inverted = False\n+        target.vertical_velocity = 0\n+        bolt = ChaosBolt(200, 100, [1, 0], 25.0, 15.0, shooter.id)\n+        arena.projectiles = [bolt]\n+        \n+        arena.handle_collisions(0.016)\n+        \n+        if target.location != [200, 100]: effects_triggered.add(\"swap\")\n+        if target.scale_ratio != 1.0: effects_triggered.add(\"scale\")\n+        if getattr(target, 'physics_inverted', False): effects_triggered.add(\"physics\")\n+        if target.vertical_velocity > 0: effects_triggered.add(\"launch\")\n+        \n+        if len(effects_triggered) >= 1: break # We saw at least one effect\n+\n+    assert target.health < initial_health\n+    assert len(effects_triggered) > 0, \"At least one chaos effect should have triggered\"\n+\n+def test_anomaly_orb_spawning_integration():\n+    arena = Arena(800, 600)\n+    orb = AnomalyOrb(100, 100, [100, 100], \"owner\") # Already at target\n+    orb.active = False # Signal it reached target\n+    orb.update(0.016) # Ensure state is consistent\n+    arena.projectiles.append(orb)\n+    \n+    arena.handle_collisions(0.016)\n+    \n+    # Check if a persistent projectile was spawned\n+    found_persistent = False\n+    for p in arena.projectiles:\n+        if isinstance(p, (BlackHoleProjectile, TornadoProjectile, StormCloud)):\n+            found_persistent = True\n+            break\n+    \n+    assert found_persistent, \"AnomalyOrb should spawn a persistent projectile upon reaching target\"\n+\n+def test_reality_reset_shuffle():\n+    arena = Arena(800, 600)\n+    char1 = Character(\"C1\", \"\", \"\", [100, 100])\n+    char2 = Character(\"C2\", \"\", \"\", [200, 200])\n+    arena.add_character(char1)\n+    arena.add_character(char2)\n+    \n+    # Add a weapon pickup\n+    weapon = ChaosEngine([300, 300])\n+    arena.weapon_pickups.append(weapon)\n+    \n+    # Trigger Reality Reset\n+    reset_proj = RealityResetProjectile(\"owner\")\n+    arena.projectiles.append(reset_proj)\n+    reset_proj.active = False # Trigger effect immediately on next collision check\n+    \n+    # Record initial positions\n+    initial_pos1 = list(char1.location)\n+    initial_pos2 = list(char2.location)\n+    initial_weapon_pos = list(weapon.location)\n+    \n+    # Shuffle is random, but we check if positions were swapped or moved\n+    # We run it a few times to be sure\n+    moved = False\n+    # Shuffle results might coincidentally match initial positions, but very unlikely for 3 entities.\n+    # We already added the proj and set active=False, just run one collision check.\n+    arena.handle_collisions(0.016)\n+    \n+    if (char1.location != initial_pos1 or \n+        char2.location != initial_pos2 or \n+        weapon.location != initial_weapon_pos):\n+        moved = True\n+        \n+    assert moved, \"Reality Reset should shuffle character/weapon locations\"\n+\n+def test_chaos_timer_countdown_integration():\n+    arena = Arena(800, 600)\n+    char = Character(\"C\", \"\", \"\", [100, 100])\n+    arena.add_character(char)\n+    \n+    char.physics_inverted = True\n+    char.chaos_timer = 1.0\n+    \n+    # Update arena\n+    arena.handle_collisions(0.5)\n+    assert char.chaos_timer == 0.5\n+    assert char.physics_inverted is True\n+    \n+    arena.handle_collisions(0.6)\n+    assert char.chaos_timer <= 0\n+    assert char.physics_inverted is False\n+\n+def test_chaos_engine_registration():\n+    from GameFolder.setup import setup_battle_arena\n+    arena = setup_battle_arena()\n+    \n+    assert \"The Chaos Engine\" in arena.lootpool\n+    # Check if one was spawned (as per setup.py)\n+    found = any(isinstance(w, ChaosEngine) for w in arena.weapon_pickups)\n+    assert found"}]}