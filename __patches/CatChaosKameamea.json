{
  "name_of_backup": "20260104161653_GameFolder",
  "changes": [
    {
      "path": "GameFolder/arenas/GAME_arena.py",
      "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,15 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.ChaosEngine import ChaosEngine, RealityResetProjectile\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n import pygame\n import random\n import math\n@@ -26,6 +35,12 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"ChaosEngine\", ChaosEngine)\n+        self.register_weapon_type(\"CatRainGun\", CatRainGun)\n+        self.register_weapon_type(\"KamehamehaGun\", KamehamehaGun)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +62,11 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, ChaosBolt, AnomalyOrb, RealityResetProjectile, CatCloud, KamehamehaProjectile)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -61,23 +80,75 @@\n         \n         # Manually handle special/persistent projectiles\n         for proj in special_projs:\n-            # Special case for OrbitalStrikeMarker: check transition even if inactive at start of loop\n-            if isinstance(proj, OrbitalStrikeMarker) and not proj.active:\n+            # Update if active\n+            if proj.active:\n+                proj.update(delta_time)\n+\n+            # Post-update check: Handle transitions for special projectiles that just became inactive\n+            if not proj.active and isinstance(proj, OrbitalStrikeMarker):\n                 blast = OrbitalBlast(proj.location[0], proj.owner_id)\n                 if blast not in self.projectiles:\n                     self.projectiles.append(blast)\n-                continue\n+                continue # Don't re-add marker to active projectiles\n+\n+            if proj.active and isinstance(proj, ChaosBolt):\n+                for char in self.characters:\n+                    if not char.is_alive or char.id == proj.owner_id: continue\n+                    \n+                    char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                    char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                    \n+                    proj_rect = pygame.Rect(proj.location[0], self.height - proj.location[1] - proj.height, proj.width, proj.height)\n+                    \n+                    if char_rect.colliderect(proj_rect):\n+                        char.take_damage(proj.damage)\n+                        proj.active = False\n+                        \n+                        # Chaos Bolt Hit Effect\n+                        effect = random.randint(0, 3)\n+                        if effect == 0: # Swap locations\n+                            owner = next((c for c in self.characters if c.id == proj.owner_id), None)\n+                            if owner:\n+                                owner.location, char.location = list(char.location), list(owner.location)\n+                        elif effect == 1: # Random scale\n+                            char.scale_ratio = random.uniform(0.5, 2.0)\n+                        elif effect == 2: # Inverted physics\n+                            char.physics_inverted = True\n+                            if not hasattr(char, 'chaos_timer'): char.chaos_timer = 0\n+                            char.chaos_timer = 3.0\n+                        elif effect == 3: # Launch upwards\n+                            char.vertical_velocity = 25.0\n+\n+            elif not proj.active and isinstance(proj, AnomalyOrb):\n+                # Reached target or collided\n+                spawn_type = random.choice([BlackHoleProjectile, TornadoProjectile, StormCloud])\n+                new_proj = None\n+                if spawn_type == BlackHoleProjectile:\n+                    new_proj = BlackHoleProjectile(proj.location[0], proj.location[1], proj.location[0], proj.location[1], proj.owner_id)\n+                elif spawn_type == TornadoProjectile:\n+                    new_proj = TornadoProjectile(proj.location[0], proj.location[1], [0, 1], 0.5, proj.owner_id)\n+                elif spawn_type == StormCloud:\n+                    new_proj = StormCloud(proj.location[0], proj.location[1], proj.location, proj.owner_id)\n+                \n+                if new_proj:\n+                    self.projectiles.append(new_proj)\n+                continue # Don't re-add orb\n+\n+            elif not proj.active and isinstance(proj, RealityResetProjectile):\n+                # Reality Reset: Shuffle characters and weapon pickups\n+                spawn_points = [list(c.location) for c in self.characters]\n+                spawn_points.extend([list(w.location) for w in self.weapon_pickups])\n+                random.shuffle(spawn_points)\n+                \n+                for char in self.characters:\n+                    if spawn_points:\n+                        char.location = spawn_points.pop()\n+                for weapon in self.weapon_pickups:\n+                    if spawn_points:\n+                        weapon.location = spawn_points.pop()\n+                continue # Don't re-add reset projectile\n \n             if not proj.active:\n-                continue\n-                \n-            proj.update(delta_time)\n-\n-            # Check if OrbitalStrikeMarker became inactive during update\n-            if isinstance(proj, OrbitalStrikeMarker) and not proj.active:\n-                blast = OrbitalBlast(proj.location[0], proj.owner_id)\n-                if blast not in self.projectiles:\n-                    self.projectiles.append(blast)\n                 continue\n \n             if isinstance(proj, StormCloud):\n@@ -142,6 +213,12 @@\n                                 char.take_damage(proj.damage * delta_time * 60)\n             \n             \n+            elif isinstance(proj, CatCloud) and proj.is_raining:\n+                # IMPORTANT: In this custom loop, self.projectiles is standard_projs\n+                # We must add to standard_projs so they are handled by super().handle_collisions\n+                # OR add to self.projectiles AFTER the loop, but here special_projs are NOT in self.projectiles.\n+                new_cats = proj.spawn_cats(delta_time)\n+                standard_projs.extend(new_cats)\n             elif isinstance(proj, TornadoProjectile):\n                 # Conical pull logic: wider at top, pulls characters, weapons, and platforms\n                 for char in self.characters:\n@@ -227,6 +304,56 @@\n                     if char.location[0] < beam_x_max and char.location[0] + char_w > beam_x_min:\n                         char.take_damage(proj.damage * delta_time)\n             \n+            elif isinstance(proj, KamehamehaProjectile):\n+                # Find owner to anchor and apply recoil\n+                owner = next((c for c in self.characters if c.id == proj.owner_id), None)\n+                if owner and owner.is_alive:\n+                    # Anchor to owner center\n+                    owner_center_x = owner.location[0] + (owner.width * owner.scale_ratio) / 2\n+                    owner_center_y = owner.location[1] + (owner.height * owner.scale_ratio) / 2\n+                    proj.location = [owner_center_x, owner_center_y]\n+                    \n+                    if proj.state == 'FIRING':\n+                        # Apply recoil to owner (push away from beam direction)\n+                        recoil_strength = 250.0 # units per second\n+                        owner.location[0] -= proj.direction[0] * recoil_strength * delta_time\n+                        owner.location[1] -= proj.direction[1] * recoil_strength * delta_time\n+                        \n+                        # Beam Collision Logic\n+                        for char in self.characters:\n+                            if not char.is_alive or char.id == proj.owner_id:\n+                                continue\n+                            \n+                            # Character center\n+                            c_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+                            c_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+                            \n+                            # Vector from beam start to character\n+                            dx = c_center_x - proj.location[0]\n+                            dy = c_center_y - proj.location[1]\n+                            \n+                            # Projection of (dx, dy) onto beam direction\n+                            dot = dx * proj.direction[0] + dy * proj.direction[1]\n+                            \n+                            # If character is in front of the beam and within beam length\n+                            if 0 <= dot <= proj.beam_length:\n+                                # Closest point on the line\n+                                closest_x = proj.location[0] + proj.direction[0] * dot\n+                                closest_y = proj.location[1] + proj.direction[1] * dot\n+                                \n+                                # Distance from character center to closest point\n+                                dist_sq = (c_center_x - closest_x)**2 + (c_center_y - closest_y)**2\n+                                hit_radius = 45 # Beam radius approx\n+                                \n+                                if dist_sq < hit_radius**2:\n+                                    # Apply continuous damage\n+                                    char.take_damage(proj.damage * delta_time)\n+                                    \n+                                    # Apply knockback (in direction of beam)\n+                                    knockback_force = 400.0\n+                                    char.location[0] += proj.direction[0] * knockback_force * delta_time\n+                                    char.location[1] += proj.direction[1] * knockback_force * delta_time\n+\n             # Put persistent projectile back into active list\n             if proj.active:\n                 self.projectiles.append(proj)\n@@ -237,6 +364,12 @@\n                 if proj in self.projectiles:\n                     self.projectiles.remove(proj)\n \n+        # Handle character chaos timer (inverted physics)\n+        for char in self.characters:\n+            if hasattr(char, 'chaos_timer') and char.chaos_timer > 0:\n+                char.chaos_timer -= delta_time\n+                if char.chaos_timer <= 0:\n+                    char.physics_inverted = False\n         for plat in self.platforms[1:]: # Skip floor\n             if not getattr(plat, 'being_pulled', False):\n                 plat.return_to_origin(delta_time)"
    },
    {
      "path": "GameFolder/projectiles/CatProjectiles.py",
      "diff": "--- a/GameFolder/projectiles/CatProjectiles.py\n+++ b/GameFolder/projectiles/CatProjectiles.py\n@@ -0,0 +1,100 @@\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+import pygame\n+import math\n+import random\n+\n+class FallingCat(Projectile):\n+    def __init__(self, x, y, owner_id):\n+        # Direction: [0, -1] (World coordinates, moving down)\n+        # Size: ~20x20 pixels\n+        super().__init__(x, y, [0, -1], 10, 5, owner_id, 20, 20)\n+        self.color = (255, 165, 0)  # Orange\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+\n+        # Body (orange ellipse)\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+\n+        # Ears (two small triangles)\n+        ear_color = self.color\n+        # Left ear\n+        le_p1 = (py_rect.left, py_rect.top + 5)\n+        le_p2 = (py_rect.left + 5, py_rect.top - 5)\n+        le_p3 = (py_rect.left + 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [le_p1, le_p2, le_p3])\n+\n+        # Right ear\n+        re_p1 = (py_rect.right, py_rect.top + 5)\n+        re_p2 = (py_rect.right - 5, py_rect.top - 5)\n+        re_p3 = (py_rect.right - 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [re_p1, re_p2, re_p3])\n+\n+class CatCloud(Projectile):\n+    def __init__(self, x, y, target_pos, owner_id):\n+        # Travels to a target position, then stays there for a duration (e.g., 5.0s)\n+        super().__init__(x, y, [0, 0], 12, 0, owner_id, 80, 40)\n+        self.target_pos = target_pos\n+        self.is_raining = False\n+        self.cat_spawn_timer = 0.0\n+        self.rain_duration = 5.0\n+        self.rain_timer = 0.0\n+        self.spawn_interval = 0.2\n+        self.persistent = True # Keep it alive in the arena\n+\n+    def update(self, delta_time):\n+        if self.is_raining:\n+            # Stationary and raining\n+            self.rain_timer += delta_time\n+            if self.rain_timer >= self.rain_duration:\n+                self.active = False\n+        else:\n+            # Move towards target_pos\n+            dx = self.target_pos[0] - self.location[0]\n+            dy = self.target_pos[1] - self.location[1]\n+            dist = math.hypot(dx, dy)\n+            move_dist = self.speed * (delta_time * 60)\n+\n+            if dist <= move_dist:\n+                self.location[0] = self.target_pos[0]\n+                self.location[1] = self.target_pos[1]\n+                self.is_raining = True\n+            else:\n+                self.location[0] += (dx / dist) * move_dist\n+                self.location[1] += (dy / dist) * move_dist\n+        \n+        # Do NOT call super().update() because it would move based on self.direction\n+        # and potentially move it off target.\n+\n+    def spawn_cats(self, delta_time):\n+        new_cats = []\n+        if self.is_raining and self.active:\n+            self.cat_spawn_timer += delta_time\n+            while self.cat_spawn_timer >= self.spawn_interval:\n+                # Spawn at random x within cloud width\n+                spawn_x = self.location[0] + random.uniform(0, self.width - 20)\n+                spawn_y = self.location[1] # Start from cloud bottom/center\n+                new_cats.append(FallingCat(spawn_x, spawn_y, self.owner_id))\n+                self.cat_spawn_timer -= self.spawn_interval\n+        return new_cats\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        py_y = arena_height - self.location[1] - self.height\n+        \n+        # Fluffy white/gray cloud (multiple ellipses)\n+        cloud_color = (240, 240, 240)\n+        rects = [\n+            pygame.Rect(self.location[0], py_y + 10, self.width, self.height - 10),\n+            pygame.Rect(self.location[0] + 10, py_y, self.width - 20, self.height),\n+            pygame.Rect(self.location[0] + 20, py_y - 5, self.width - 40, self.height - 10)\n+        ]\n+        for r in rects:\n+            pygame.draw.ellipse(screen, cloud_color, r)"
    },
    {
      "path": "GameFolder/projectiles/ChaosProjectiles.py",
      "diff": "--- a/GameFolder/projectiles/ChaosProjectiles.py\n+++ b/GameFolder/projectiles/ChaosProjectiles.py\n@@ -0,0 +1,61 @@\n+import pygame\n+import math\n+import time\n+import colorsys\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class ChaosBolt(Projectile):\n+    def __init__(self, x: float, y: float, direction: list[float, float], speed: float, damage: float, owner_id: str):\n+        # Faster than normal projectiles (multiplier applied here or in weapon)\n+        super().__init__(x, y, direction, speed, damage, owner_id, width=12, height=12)\n+        self.frequency = 2.0  # Speed of color shifting\n+\n+    def update(self, delta_time: float):\n+        super().update(delta_time)\n+        # Update color with rainbow-shifting HSL\n+        hue = (time.time() * self.frequency) % 1.0\n+        rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)\n+        self.color = (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        \n+        # Draw with a slight trail or glow effect using the rainbow color\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+        # Glitchy inner core\n+        inner_color = (255 - self.color[0], 255 - self.color[1], 255 - self.color[2])\n+        inner_rect = py_rect.inflate(-4, -4)\n+        pygame.draw.ellipse(screen, inner_color, inner_rect)\n+\n+class AnomalyOrb(Projectile):\n+    def __init__(self, x: float, y: float, target_pos: list[float, float], owner_id: str):\n+        # Travels towards target_pos\n+        dx = target_pos[0] - x\n+        dy = target_pos[1] - y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist > 0 else [0, 0]\n+        \n+        super().__init__(x, y, direction, speed=8, damage=0, owner_id=owner_id, width=20, height=20)\n+        self.target_pos = target_pos\n+        self.color = (150, 0, 200) # Purple/Anomaly color\n+\n+    def update(self, delta_time: float):\n+        dx = self.target_pos[0] - self.location[0]\n+        dy = self.target_pos[1] - self.location[1]\n+        dist = math.hypot(dx, dy)\n+        \n+        move_dist = self.speed * (delta_time * 60)\n+        \n+        if dist <= move_dist:\n+            self.location[0] = self.target_pos[0]\n+            self.location[1] = self.target_pos[1]\n+            # When it reaches target_pos, it sets active = False \n+            # Arena should spawn random persistent projectile here\n+            self.active = False\n+        else:\n+            self.location[0] += self.direction[0] * move_dist\n+            self.location[1] += self.direction[1] * move_dist"
    },
    {
      "path": "GameFolder/projectiles/KamehamehaProjectile.py",
      "diff": "--- a/GameFolder/projectiles/KamehamehaProjectile.py\n+++ b/GameFolder/projectiles/KamehamehaProjectile.py\n@@ -0,0 +1,105 @@\n+import pygame\n+import math\n+import random\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class KamehamehaProjectile(Projectile):\n+    def __init__(self, x: float, y: float, direction: list, owner_id: str, damage: float):\n+        # Initialize with speed 0 because it's anchored to owner or behaves like a beam\n+        super().__init__(x, y, direction, 0, damage, owner_id, width=40, height=40)\n+        self.state = 'CHARGING'\n+        self.timer = 0.0\n+        self.charge_duration = 1.2\n+        self.fire_duration = 1.5\n+        self.beam_length = 2000 # Large enough to cross arena\n+        self.pulse_timer = 0.0\n+        \n+        # For visual effects\n+        self.charge_particles = []\n+        for _ in range(12):\n+            self.charge_particles.append({\n+                'angle': random.uniform(0, math.pi * 2),\n+                'dist': random.uniform(30, 60),\n+                'speed': random.uniform(1, 3)\n+            })\n+\n+    def update(self, delta_time: float):\n+        self.timer += delta_time\n+        self.pulse_timer += delta_time\n+        \n+        if self.state == 'CHARGING':\n+            if self.timer >= self.charge_duration:\n+                self.state = 'FIRING'\n+                self.timer = 0.0\n+            \n+            # Update charge particles\n+            for p in self.charge_particles:\n+                p['dist'] -= p['speed'] * (delta_time * 60)\n+                if p['dist'] < 5:\n+                    p['dist'] = random.uniform(40, 70)\n+                    p['angle'] = random.uniform(0, math.pi * 2)\n+                    \n+        elif self.state == 'FIRING':\n+            if self.timer >= self.fire_duration:\n+                self.active = False\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1]\n+        py_x = self.location[0]\n+\n+        if self.state == 'CHARGING':\n+            # Pulsing blue orb\n+            pulse = (math.sin(self.pulse_timer * 15) + 1) * 0.5\n+            radius = 15 + pulse * 10\n+            \n+            # Outer Glow\n+            pygame.draw.circle(screen, (0, 100, 255), (int(py_x), int(py_y)), int(radius + 5), 2)\n+            # Core\n+            pygame.draw.circle(screen, (200, 230, 255), (int(py_x), int(py_y)), int(radius))\n+            \n+            # Draw gathering particles\n+            for p in self.charge_particles:\n+                px = py_x + math.cos(p['angle']) * p['dist']\n+                py = py_y + math.sin(p['angle']) * p['dist']\n+                pygame.draw.circle(screen, (100, 200, 255), (int(px), int(py)), 3)\n+\n+        elif self.state == 'FIRING':\n+            # Beam visual\n+            flicker = random.randint(-5, 5)\n+            beam_width = 60 + flicker\n+            \n+            # Calculate end point based on direction\n+            end_x = py_x + self.direction[0] * self.beam_length\n+            end_y = py_y - self.direction[1] * self.beam_length # y-up logic to y-down screen\n+            \n+            # Draw beam layers\n+            # 1. Outer Glow\n+            pygame.draw.line(screen, (0, 150, 255), (py_x, py_y), (end_x, end_y), int(beam_width + 20))\n+            # 2. Main Blue\n+            pygame.draw.line(screen, (100, 200, 255), (py_x, py_y), (end_x, end_y), int(beam_width))\n+            # 3. White Core\n+            pygame.draw.line(screen, (255, 255, 255), (py_x, py_y), (end_x, end_y), int(beam_width // 2))\n+            \n+            # Flickering Orbs along the beam\n+            for i in range(10):\n+                dist_ratio = ( (self.pulse_timer * 2 + i/10.0) % 1.0 )\n+                bx = py_x + self.direction[0] * self.beam_length * dist_ratio\n+                by = py_y - self.direction[1] * self.beam_length * dist_ratio\n+                pygame.draw.circle(screen, (255, 255, 255), (int(bx), int(by)), random.randint(5, 15))\n+\n+            # Start Orb\n+            pygame.draw.circle(screen, (200, 230, 255), (int(py_x), int(py_y)), int(beam_width // 1.2))\n+\n+    def get_rect(self) -> pygame.Rect:\n+        # For the beam, the 'rect' is tricky. \n+        # Usually collisions are handled by the arena for beams, \n+        # but we'll return a representative rect of the firing point for now.\n+        if self.state == 'FIRING':\n+            # Large bounding box for simple logic or specific beam collision logic in Arena\n+            return pygame.Rect(self.location[0] - 50, self.location[1] - 50, 100, 100)\n+        else:\n+            return pygame.Rect(self.location[0] - 20, self.location[1] - 20, 40, 40)"
    },
    {
      "path": "GameFolder/setup.py",
      "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,12 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.ChaosEngine import ChaosEngine\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +50,19 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"The Chaos Engine\", ChaosEngine)\n+    arena.register_weapon_type(\"Cat Rain Gun\", CatRainGun)\n+    arena.register_weapon_type(\"Kamehameha Gun\", KamehamehaGun)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(ChaosEngine([600, 100]))\n+    arena.spawn_weapon(CatRainGun([600, 400]))\n+    arena.spawn_weapon(KamehamehaGun([600, 400]))\n     \n     return arena"
    },
    {
      "path": "GameFolder/tests/cat_rain_tests.py",
      "diff": "--- a/GameFolder/tests/cat_rain_tests.py\n+++ b/GameFolder/tests/cat_rain_tests.py\n@@ -0,0 +1,172 @@\n+import math\n+import pygame\n+import pytest\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.setup import setup_battle_arena\n+\n+def test_cat_rain_gun_properties():\n+    \"\"\"Verify CatRainGun initial properties.\"\"\"\n+    gun = CatRainGun()\n+    assert gun.name == \"Cat Rain Gun\"\n+    assert gun.cooldown == 5.0\n+    assert gun.color == (255, 165, 0)\n+\n+def test_cat_rain_gun_shooting():\n+    \"\"\"Verify CatRainGun spawns a CatCloud.\"\"\"\n+    gun = CatRainGun()\n+    gun.last_shot_time = 0 \n+    cloud = gun.shoot(100, 100, 200, 300, \"player1\")\n+    assert isinstance(cloud, CatCloud)\n+    assert cloud.target_pos == [200, 300]\n+    assert cloud.owner_id == \"player1\"\n+\n+def test_cat_cloud_movement():\n+    \"\"\"Verify CatCloud moves towards target then starts raining.\"\"\"\n+    # Start at 100,100 target 200,100. Speed 12.\n+    cloud = CatCloud(100, 100, [200, 100], \"player1\")\n+    assert not cloud.is_raining\n+    \n+    # Move partway. Speed=12, dt=0.1. move_dist = 12 * (0.1*60) = 72.\n+    cloud.update(0.1) \n+    assert cloud.location[0] == 172\n+    assert not cloud.is_raining\n+    \n+    # Move to target. Remaining dist = 28. Next move will be 72, which is > 28.\n+    cloud.update(0.1)\n+    assert cloud.is_raining, \"Cloud should be raining after reaching target\"\n+    assert cloud.location == [200, 100]\n+\n+def test_cat_cloud_spawning():\n+    \"\"\"Verify CatCloud spawns FallingCat projectiles when raining.\"\"\"\n+    cloud = CatCloud(200, 400, [200, 400], \"player1\")\n+    cloud.is_raining = True\n+    cloud.active = True\n+    \n+    # spawn_interval is 0.2\n+    cats = cloud.spawn_cats(0.1)\n+    assert len(cats) == 0\n+    \n+    cats = cloud.spawn_cats(0.15)\n+    assert len(cats) == 1\n+    assert isinstance(cats[0], FallingCat)\n+    assert cats[0].owner_id == \"player1\"\n+    # Spawned at cloud x (200) to 200+width-20 (200+80-20=260)\n+    assert 200 <= cats[0].location[0] <= 260\n+    assert cats[0].location[1] == 400\n+\n+def test_falling_cat_movement():\n+    \"\"\"Verify FallingCat moves downwards.\"\"\"\n+    cat = FallingCat(200, 400, \"player1\")\n+    # Speed 10, Direction [0, -1].\n+    # move_dist = 10 * (0.1 * 60) = 60.\n+    cat.update(0.1)\n+    assert cat.location[1] == 400 - 60\n+    assert cat.location[0] == 200\n+\n+def test_falling_cat_deals_damage():\n+    \"\"\"Verify FallingCat deals damage on collision in Arena.\"\"\"\n+    arena = Arena(800, 600)\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    target.id = \"target\"\n+    target.defense = 0\n+    arena.characters.append(target)\n+    \n+    # Cat falling right on target.\n+    # Character is at [200, 100], width 45.\n+    # Cat is at [210, 150], width 20.\n+    cat = FallingCat(210, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    initial_health = target.health\n+    \n+    # Run arena until collision\n+    # Cat speed 10. dist to target top is roughly 50.\n+    for _ in range(10):\n+        arena.handle_collisions(0.016)\n+        if target.health < initial_health:\n+            break\n+            \n+    assert target.health < initial_health\n+    assert target.health == initial_health - cat.damage\n+    assert not cat.active\n+\n+def test_cat_cloud_duration():\n+    \"\"\"Verify CatCloud deactivates after rain duration.\"\"\"\n+    cloud = CatCloud(100, 100, [100, 100], \"player1\")\n+    cloud.is_raining = True\n+    cloud.rain_timer = 0\n+    \n+    cloud.update(cloud.rain_duration - 0.1)\n+    assert cloud.active\n+    \n+    cloud.update(0.2)\n+    assert not cloud.active\n+\n+def test_cat_rain_gun_registration():\n+    \"\"\"Verify CatRainGun is registered in setup_battle_arena.\"\"\"\n+    arena = setup_battle_arena()\n+    # Check lootpool\n+    assert \"Cat Rain Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Cat Rain Gun\"] == CatRainGun\n+    \n+    # Check if one was spawned (as per setup.py)\n+    found = False\n+    for w in arena.weapon_pickups:\n+        if isinstance(w, CatRainGun):\n+            found = True\n+            break\n+    assert found, \"Cat Rain Gun should be spawned in the arena\"\n+\n+def test_integration_cat_cloud_in_arena():\n+    \"\"\"Verify CatCloud spawns cats inside the Arena update loop.\"\"\"\n+    arena = Arena(800, 600)\n+    cloud = CatCloud(200, 500, [200, 500], \"player1\")\n+    cloud.is_raining = True\n+    arena.projectiles.append(cloud)\n+    \n+    # Run for 0.5s. With spawn_interval 0.2, should spawn at least 2 cats.\n+    # handle_collisions(0.1) called 5 times.\n+    for _ in range(5):\n+        arena.handle_collisions(0.1)\n+        \n+    # Check if cats exist in arena.projectiles\n+    # Note: they might have fallen off or been removed if they hit floor, \n+    # but at speed 10, in 0.5s they move 10*60*0.5 = 300. \n+    # Starting at 500, they would be at 200. Floor is usually at 120 or 0.\n+    \n+    cats = [p for p in arena.projectiles if isinstance(p, FallingCat)]\n+    assert len(cats) >= 2\n+    assert cloud in arena.projectiles\n+\n+def test_falling_cat_hits_platform():\n+    \"\"\"Verify FallingCat is deactivated when hitting a platform.\"\"\"\n+    arena = Arena(800, 600)\n+    # Platform at Screen Y=500, Height 20. \n+    # World Y = 600 - 500 - 20 = 80.\n+    from GameFolder.platforms.GAME_platform import Platform\n+    plat = Platform(100, 500, 200, 20)\n+    arena.add_platform(plat)\n+    \n+    # Cat above platform\n+    cat = FallingCat(150, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    # Move cat down to hit platform\n+    for _ in range(20):\n+        arena.handle_collisions(0.016)\n+        if not cat.active:\n+            break\n+            \n+    assert not cat.active, \"Cat should deactivate on hitting platform\"\n+\n+def test_cat_cloud_diagonal_movement():\n+    \"\"\"Verify CatCloud moves correctly on diagonal path.\"\"\"\n+    cloud = CatCloud(0, 0, [100, 100], \"player1\")\n+    cloud.update(0.1) # move_dist = 72\n+    # Diagonal distance 141.4. move_dist 72.\n+    # move_x = (100/141.4) * 72 = 0.707 * 72 = 50.9\n+    assert 50 < cloud.location[0] < 52\n+    assert 50 < cloud.location[1] < 52"
    },
    {
      "path": "GameFolder/tests/kamehameha_tests.py",
      "diff": "--- a/GameFolder/tests/kamehameha_tests.py\n+++ b/GameFolder/tests/kamehameha_tests.py\n@@ -0,0 +1,203 @@\n+\"\"\"\n+Tests for Kamehameha Weapon and Projectile\n+\"\"\"\n+import pytest\n+import math\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n+from GameFolder.arenas.GAME_arena import Arena\n+\n+def test_kamehameha_gun_creation():\n+    \"\"\"Test that the Kamehameha gun initializes with correct values.\"\"\"\n+    gun = KamehamehaGun(location=[100, 100])\n+    assert gun.name == \"Kamehameha\"\n+    assert gun.damage == 50.0\n+    assert gun.cooldown == 5.0\n+    assert gun.location == [100, 100]\n+\n+def test_kamehameha_gun_shooting():\n+    \"\"\"Test that shooting returns a KamehamehaProjectile and triggers cooldown.\"\"\"\n+    gun = KamehamehaGun()\n+    # Initial shot should succeed\n+    projs = gun.shoot(owner_x=100, owner_y=100, target_x=200, target_y=100, owner_id=\"test_owner\")\n+    assert projs is not None\n+    assert len(projs) == 1\n+    assert isinstance(projs[0], KamehamehaProjectile)\n+    assert projs[0].owner_id == \"test_owner\"\n+    \n+    # Immediate second shot should fail due to cooldown\n+    projs2 = gun.shoot(owner_x=100, owner_y=100, target_x=200, target_y=100, owner_id=\"test_owner\")\n+    assert projs2 is None\n+\n+def test_kamehameha_projectile_states():\n+    \"\"\"Test that the Kamehameha projectile transitions through its states correctly.\"\"\"\n+    proj = KamehamehaProjectile(x=100, y=100, direction=[1, 0], owner_id=\"owner\", damage=50.0)\n+    assert proj.state == 'CHARGING'\n+    assert proj.active\n+    \n+    # Update to nearly finish charging\n+    dt = 0.1\n+    total_time = 0.0\n+    while total_time < proj.charge_duration - 0.05:\n+        proj.update(dt)\n+        total_time += dt\n+        assert proj.state == 'CHARGING'\n+    \n+    # One more update to transition to FIRING\n+    proj.update(0.1)\n+    assert proj.state == 'FIRING'\n+    \n+    # Update through FIRING duration\n+    total_firing_time = 0.0\n+    while total_firing_time < proj.fire_duration - 0.05:\n+        proj.update(dt)\n+        total_firing_time += dt\n+        assert proj.state == 'FIRING'\n+        assert proj.active\n+        \n+    # Final update to deactivate\n+    proj.update(0.1)\n+    assert not proj.active\n+\n+def test_kamehameha_integration_anchoring_and_recoil():\n+    \"\"\"Test anchoring to owner and recoil application in the Arena.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    char = Character(\"Shooter\", \"char1\", \"char1\", [500, 500])\n+    arena.characters = [char]\n+    \n+    # Give shooter the gun\n+    gun = KamehamehaGun()\n+    char.weapon = gun\n+    \n+    # Shoot right\n+    projs = char.shoot([600, 500])\n+    arena.projectiles.extend(projs)\n+    proj = projs[0]\n+    \n+    # 1. CHARGING State - Anchoring check\n+    char.location = [550, 550] # Move character during charging\n+    arena.handle_collisions(0.1)\n+    \n+    # Projectile should follow character center\n+    char_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+    char_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+    assert proj.location[0] == char_center_x\n+    assert proj.location[1] == char_center_y\n+    \n+    # No recoil during charging\n+    assert char.location == [550, 550]\n+    \n+    # 2. Transition to FIRING\n+    for _ in range(15): # Step past 1.2s charge\n+        arena.handle_collisions(0.1)\n+    \n+    assert proj.state == 'FIRING'\n+    \n+    # 3. FIRING State - Recoil check\n+    initial_loc = list(char.location)\n+    arena.handle_collisions(0.1)\n+    \n+    # Character should be pushed LEFT if shooting RIGHT ([1, 0])\n+    # recoil_strength is 250 units/s. In 0.1s, should move 25 units.\n+    assert char.location[0] < initial_loc[0]\n+    assert math.isclose(char.location[0], initial_loc[0] - 25.0, abs_tol=0.1)\n+\n+def test_kamehameha_integration_beam_collision():\n+    \"\"\"Test beam collision detection and damage application in the Arena.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    shooter = Character(\"Shooter\", \"char1\", \"char1\", [100, 500])\n+    target = Character(\"Target\", \"char2\", \"char2\", [300, 500])\n+    arena.characters = [shooter, target]\n+    \n+    # Shoot right at target\n+    gun = KamehamehaGun()\n+    shooter.weapon = gun\n+    projs = shooter.shoot([400, 500])\n+    arena.projectiles.extend(projs)\n+    proj = projs[0]\n+    \n+    # Skip charging\n+    for _ in range(15):\n+        arena.handle_collisions(0.1)\n+    \n+    assert proj.state == 'FIRING'\n+    \n+    # Check damage and knockback\n+    initial_hp = target.hp\n+    initial_x = target.location[0]\n+    \n+    arena.handle_collisions(0.1)\n+    \n+    assert target.hp < initial_hp\n+    assert target.location[0] > initial_x # Knockback to the right\n+    \n+    # Test target out of beam radius (above)\n+    target.location = [300, 700] \n+    target.hp = 100\n+    initial_x = target.location[0]\n+    arena.handle_collisions(0.1)\n+    \n+    assert target.hp == 100 # No damage\n+    assert target.location[0] == initial_x # No knockback\n+\n+def test_kamehameha_edge_cases():\n+    \"\"\"Test firing from boundaries and corners.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    gun = KamehamehaGun()\n+    \n+    # Corner: Bottom-Left shooting Top-Right\n+    projs = gun.shoot(0, 0, 1000, 1000, \"owner\")\n+    proj = projs[0]\n+    assert math.isclose(proj.direction[0], 0.707, abs_tol=0.01)\n+    assert math.isclose(proj.direction[1], 0.707, abs_tol=0.01)\n+    \n+    # Boundary: Top edge shooting down\n+    projs = gun.shoot(500, 1000, 500, 0, \"owner\")\n+    proj = projs[0]\n+    assert proj.direction == [0, -1]\n+\n+def test_kamehameha_lootpool_registration():\n+    \"\"\"Test that KamehamehaGun is registered in the arena's lootpool.\"\"\"\n+    from GameFolder.setup import setup_battle_arena\n+    arena = setup_battle_arena()\n+    assert \"Kamehameha Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Kamehameha Gun\"] == KamehamehaGun\n+\n+def test_kamehameha_owner_death():\n+    \"\"\"Test that projectile continues if owner dies (or behavior depends on implementation).\n+    In current Arena implementation, it checks `if owner and owner.is_alive`.\n+    If owner is dead, anchoring and recoil stop.\n+    \"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    shooter = Character(\"Shooter\", \"char1\", \"char1\", [100, 500])\n+    arena.characters = [shooter]\n+    proj = KamehamehaProjectile(100, 500, [1, 0], shooter.id, 50.0)\n+    arena.projectiles.append(proj)\n+    \n+    shooter.hp = 0 # Kill shooter\n+    arena.handle_collisions(0.1)\n+    \n+    # Should not crash, and proj location should not have changed if it didn't find owner\n+    assert proj.location == [100, 500]\n+\n+def test_kamehameha_origin_scenarios():\n+    \"\"\"Test firing from specific origins requested in instructions.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    gun = KamehamehaGun()\n+    \n+    # 1. Center\n+    projs = gun.shoot(500, 500, 600, 500, \"owner\")\n+    assert projs[0].location == [500, 500]\n+    \n+    # 2. Close to another character\n+    shooter = Character(\"S\", \"s\", \"s\", [500, 500])\n+    target = Character(\"T\", \"t\", \"t\", [510, 500]) # 10 units away\n+    arena.characters = [shooter, target]\n+    shooter.weapon = gun\n+    projs = shooter.shoot([510, 500])\n+    arena.projectiles.extend(projs)\n+    \n+    # Move to firing state\n+    for _ in range(15): arena.handle_collisions(0.1)\n+    assert target.hp < 100, \"Target very close to shooter should be hit immediately by beam\""
    },
    {
      "path": "GameFolder/tests/test_chaos_engine.py",
      "diff": "--- a/GameFolder/tests/test_chaos_engine.py\n+++ b/GameFolder/tests/test_chaos_engine.py\n@@ -0,0 +1,188 @@\n+import pytest\n+import pygame\n+import time\n+import random\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.weapons.ChaosEngine import ChaosEngine, RealityResetProjectile\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.projectiles.BlackHoleProjectile import BlackHoleProjectile\n+from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n+from GameFolder.projectiles.GAME_projectile import StormCloud\n+\n+def test_chaos_engine_initialization():\n+    weapon = ChaosEngine([100, 100])\n+    assert weapon.name == \"The Chaos Engine\"\n+    assert weapon.damage == 15\n+    assert weapon.projectile_speed == 25.0\n+    assert weapon.secondary_cooldown == 4.0\n+    assert weapon.special_cooldown == 12.0\n+\n+def test_chaos_bolt_mechanics():\n+    shooter_id = \"shooter\"\n+    bolt = ChaosBolt(100, 100, [1, 0], 25.0, 15.0, shooter_id)\n+    \n+    # Test movement\n+    bolt.update(0.016)\n+    assert bolt.location[0] > 100\n+    \n+    # Test color update (rainbow shifting)\n+    initial_color = bolt.color\n+    time.sleep(0.1) # Ensure time passes for color shift\n+    bolt.update(0.016)\n+    assert bolt.color != initial_color\n+\n+def test_anomaly_orb_movement_and_deactivation():\n+    target_pos = [200, 200]\n+    orb = AnomalyOrb(100, 100, target_pos, \"owner\")\n+    \n+    # Simulate movement until it reaches target\n+    for _ in range(200):\n+        orb.update(0.016)\n+        if not orb.active:\n+            break\n+            \n+    assert orb.active is False\n+    assert orb.location[0] == pytest.approx(target_pos[0])\n+    assert orb.location[1] == pytest.approx(target_pos[1])\n+\n+def test_chaos_engine_fire_modes():\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    weapon = ChaosEngine()\n+    shooter.pickup_weapon(weapon)\n+    \n+    # Primary fire\n+    projs = shooter.shoot([200, 100])\n+    assert isinstance(projs[0], ChaosBolt)\n+    \n+    # Secondary fire\n+    weapon.last_secondary_time = 0 # Reset cooldown\n+    projs = weapon.secondary_fire(100, 100, 200, 200, shooter.id)\n+    assert isinstance(projs[0], AnomalyOrb)\n+    \n+    # Special fire\n+    weapon.last_special_time = 0 # Reset cooldown\n+    projs = weapon.special_fire(100, 100, 200, 200, shooter.id, is_holding=False)\n+    assert isinstance(projs[0], RealityResetProjectile)\n+\n+def test_chaos_bolt_collision_effects():\n+    # Since effects are random, we test that SOMETHING changed on the character\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    arena.add_character(shooter)\n+    arena.add_character(target)\n+    \n+    # Force a ChaosBolt collision\n+    bolt = ChaosBolt(200, 100, [1, 0], 25.0, 15.0, shooter.id)\n+    arena.projectiles.append(bolt)\n+    \n+    initial_health = target.health\n+    initial_pos = list(target.location)\n+    initial_scale = target.scale_ratio\n+    \n+    # Mock random to ensure we get a specific effect if we wanted, \n+    # but here we just check if any state changed\n+    # We'll run multiple times to hit different effects\n+    effects_triggered = set()\n+    \n+    for _ in range(20):\n+        target.health = 100\n+        target.location = [200, 100]\n+        target.scale_ratio = 1.0\n+        target.physics_inverted = False\n+        target.vertical_velocity = 0\n+        bolt = ChaosBolt(200, 100, [1, 0], 25.0, 15.0, shooter.id)\n+        arena.projectiles = [bolt]\n+        \n+        arena.handle_collisions(0.016)\n+        \n+        if target.location != [200, 100]: effects_triggered.add(\"swap\")\n+        if target.scale_ratio != 1.0: effects_triggered.add(\"scale\")\n+        if getattr(target, 'physics_inverted', False): effects_triggered.add(\"physics\")\n+        if target.vertical_velocity > 0: effects_triggered.add(\"launch\")\n+        \n+        if len(effects_triggered) >= 1: break # We saw at least one effect\n+\n+    assert target.health < initial_health\n+    assert len(effects_triggered) > 0, \"At least one chaos effect should have triggered\"\n+\n+def test_anomaly_orb_spawning_integration():\n+    arena = Arena(800, 600)\n+    orb = AnomalyOrb(100, 100, [100, 100], \"owner\") # Already at target\n+    orb.active = False # Signal it reached target\n+    orb.update(0.016) # Ensure state is consistent\n+    arena.projectiles.append(orb)\n+    \n+    arena.handle_collisions(0.016)\n+    \n+    # Check if a persistent projectile was spawned\n+    found_persistent = False\n+    for p in arena.projectiles:\n+        if isinstance(p, (BlackHoleProjectile, TornadoProjectile, StormCloud)):\n+            found_persistent = True\n+            break\n+    \n+    assert found_persistent, \"AnomalyOrb should spawn a persistent projectile upon reaching target\"\n+\n+def test_reality_reset_shuffle():\n+    arena = Arena(800, 600)\n+    char1 = Character(\"C1\", \"\", \"\", [100, 100])\n+    char2 = Character(\"C2\", \"\", \"\", [200, 200])\n+    arena.add_character(char1)\n+    arena.add_character(char2)\n+    \n+    # Add a weapon pickup\n+    weapon = ChaosEngine([300, 300])\n+    arena.weapon_pickups.append(weapon)\n+    \n+    # Trigger Reality Reset\n+    reset_proj = RealityResetProjectile(\"owner\")\n+    arena.projectiles.append(reset_proj)\n+    reset_proj.active = False # Trigger effect immediately on next collision check\n+    \n+    # Record initial positions\n+    initial_pos1 = list(char1.location)\n+    initial_pos2 = list(char2.location)\n+    initial_weapon_pos = list(weapon.location)\n+    \n+    # Shuffle is random, but we check if positions were swapped or moved\n+    # We run it a few times to be sure\n+    moved = False\n+    # Shuffle results might coincidentally match initial positions, but very unlikely for 3 entities.\n+    # We already added the proj and set active=False, just run one collision check.\n+    arena.handle_collisions(0.016)\n+    \n+    if (char1.location != initial_pos1 or \n+        char2.location != initial_pos2 or \n+        weapon.location != initial_weapon_pos):\n+        moved = True\n+        \n+    assert moved, \"Reality Reset should shuffle character/weapon locations\"\n+\n+def test_chaos_timer_countdown_integration():\n+    arena = Arena(800, 600)\n+    char = Character(\"C\", \"\", \"\", [100, 100])\n+    arena.add_character(char)\n+    \n+    char.physics_inverted = True\n+    char.chaos_timer = 1.0\n+    \n+    # Update arena\n+    arena.handle_collisions(0.5)\n+    assert char.chaos_timer == 0.5\n+    assert char.physics_inverted is True\n+    \n+    arena.handle_collisions(0.6)\n+    assert char.chaos_timer <= 0\n+    assert char.physics_inverted is False\n+\n+def test_chaos_engine_registration():\n+    from GameFolder.setup import setup_battle_arena\n+    arena = setup_battle_arena()\n+    \n+    assert \"The Chaos Engine\" in arena.lootpool\n+    # Check if one was spawned (as per setup.py)\n+    found = any(isinstance(w, ChaosEngine) for w in arena.weapon_pickups)\n+    assert found"
    },
    {
      "path": "GameFolder/weapons/CatRainGun.py",
      "diff": "--- a/GameFolder/weapons/CatRainGun.py\n+++ b/GameFolder/weapons/CatRainGun.py\n@@ -0,0 +1,18 @@\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.CatProjectiles import CatCloud\n+\n+class CatRainGun(Weapon):\n+    def __init__(self, location=None):\n+        # Name, damage (applied by spawned cats), cooldown, speed, location\n+        # Damage here is representative, actual damage depends on FallingCat.\n+        # Cooldown 5.0s as requested.\n+        super().__init__(\"Cat Rain Gun\", 5, 5.0, 12, location)\n+        self.color = (255, 165, 0)  # Orange like a ginger cat\n+\n+    def shoot(self, owner_x, owner_y, target_x, target_y, owner_id):\n+        \"\"\"\n+        Shoots a CatCloud projectile targeting the target location.\n+        \"\"\"\n+        target_pos = [target_x, target_y]\n+        # Create the CatCloud at the owner's position, heading to target_pos\n+        return CatCloud(owner_x, owner_y, target_pos, owner_id)"
    },
    {
      "path": "GameFolder/weapons/ChaosEngine.py",
      "diff": "--- a/GameFolder/weapons/ChaosEngine.py\n+++ b/GameFolder/weapons/ChaosEngine.py\n@@ -0,0 +1,117 @@\n+import pygame\n+import time\n+import math\n+import colorsys\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.ChaosProjectiles import ChaosBolt, AnomalyOrb\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class RealityResetProjectile(Projectile):\n+    \"\"\"\n+    A special projectile that immediately deactivates and signals the Arena \n+    to perform a 'Reality Reset' (shuffle characters and items).\n+    \"\"\"\n+    def __init__(self, owner_id: str):\n+        # Spawn at 0,0 since it's just a signal\n+        super().__init__(0, 0, [0, 0], 0, 0, owner_id)\n+        self.active = False\n+        self.is_reality_reset = True # Marker for the Arena\n+\n+class ChaosEngine(Weapon):\n+    def __init__(self, location: list[float, float] = None):\n+        # Name: \"The Chaos Engine\"\n+        # Cooldown: Primary is handled by 'cooldown' param.\n+        super().__init__(name=\"The Chaos Engine\", damage=15, cooldown=0.4, projectile_speed=25.0, location=location)\n+        \n+        self.secondary_cooldown = 4.0\n+        self.special_cooldown = 12.0\n+        self.last_secondary_time = 0.0\n+        self.last_special_time = 0.0\n+        \n+        # Visual properties\n+        self.width = 45\n+        self.height = 30\n+        self.frequency = 3.0 # For color shifting\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"Primary fire: ChaosBolt\"\"\"\n+        if not self.can_shoot():\n+            return None\n+            \n+        self.last_shot_time = time.time()\n+        \n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        direction = [dx / dist, dy / dist] if dist > 0 else [1, 0]\n+        \n+        return [ChaosBolt(owner_x, owner_y, direction, self.projectile_speed, self.damage, owner_id)]\n+\n+    def secondary_fire(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"Secondary fire: AnomalyOrb. Cooldown: 4.0s\"\"\"\n+        now = time.time()\n+        if (now - self.last_secondary_time) < self.secondary_cooldown:\n+            return None\n+            \n+        self.last_secondary_time = now\n+        return [AnomalyOrb(owner_x, owner_y, [target_x, target_y], owner_id)]\n+\n+    def special_fire(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str, is_holding: bool):\n+        \"\"\"Special fire: Reality Reset. Cooldown: 12.0s\"\"\"\n+        if is_holding: # Only trigger on initial press\n+            return None\n+            \n+        now = time.time()\n+        if (now - self.last_special_time) < self.special_cooldown:\n+            return None\n+            \n+        self.last_special_time = now\n+        return [RealityResetProjectile(owner_id)]\n+\n+    def update_color(self):\n+        \"\"\"Calculates the flickering/shifting rainbow color.\"\"\"\n+        hue = (time.time() * self.frequency) % 1.0\n+        rgb = colorsys.hsv_to_rgb(hue, 1.0, 1.0)\n+        self.color = (int(rgb[0] * 255), int(rgb[1] * 255), int(rgb[2] * 255))\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"Draw with a flickering/shifting rainbow color.\"\"\"\n+        if self.is_equipped:\n+            return\n+            \n+        self.update_color()\n+        \n+        py_y = arena_height - self.location[1] - self.height\n+        weapon_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+        \n+        # Draw shifting glow\n+        glow_size = 5 + int(math.sin(time.time() * 10) * 3)\n+        glow_rect = weapon_rect.inflate(glow_size, glow_size)\n+        pygame.draw.rect(screen, self.color, glow_rect, 2)\n+        \n+        # Draw main body\n+        pygame.draw.rect(screen, self.color, weapon_rect)\n+        \n+        # Inner \"glitch\" core\n+        inner_color = (255 - self.color[0], 255 - self.color[1], 255 - self.color[2])\n+        inner_rect = weapon_rect.inflate(-10, -10)\n+        pygame.draw.rect(screen, inner_color, inner_rect)\n+        \n+        # Border\n+        pygame.draw.rect(screen, (255, 255, 255), weapon_rect, 2)\n+        \n+        # Name text with background\n+        font = pygame.font.Font(None, 20)\n+        text = font.render(self.name, True, (255, 255, 255))\n+        text_rect = text.get_rect(center=(self.location[0] + self.width/2, py_y - 15))\n+        \n+        bg_rect = text_rect.inflate(8, 4)\n+        pygame.draw.rect(screen, (0, 0, 0), bg_rect)\n+        pygame.draw.rect(screen, (255, 255, 255), bg_rect, 1)\n+        \n+        # Text flickering shadow\n+        if int(time.time() * 20) % 2 == 0:\n+            shadow = font.render(self.name, True, self.color)\n+            screen.blit(shadow, (text_rect.x + 2, text_rect.y + 1))\n+            \n+        screen.blit(text, text_rect)\n"
    },
    {
      "path": "GameFolder/weapons/KamehamehaGun.py",
      "diff": "--- a/GameFolder/weapons/KamehamehaGun.py\n+++ b/GameFolder/weapons/KamehamehaGun.py\n@@ -0,0 +1,78 @@\n+import pygame\n+import math\n+import time\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n+\n+class KamehamehaGun(Weapon):\n+    def __init__(self, location: [float, float] = None):\n+        # Long cooldown (5 seconds) and high base damage (50)\n+        # Note: Actual damage is applied per-frame in the arena logic during the FIRING state.\n+        super().__init__(\n+            name=\"Kamehameha\",\n+            damage=50.0,\n+            cooldown=5.0,\n+            projectile_speed=0.0,  # The beam doesn't 'travel' in a traditional sense\n+            location=location\n+        )\n+        self.color = (0, 191, 255)  # Deep Sky Blue\n+        self.width = 40\n+        self.height = 30\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"\n+        Returns a KamehamehaProjectile which handles its own state (CHARGING then FIRING).\n+        \"\"\"\n+        if not self.can_shoot():\n+            return None\n+\n+        self.last_shot_time = time.time()\n+\n+        # Calculate direction\n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        if dist == 0:\n+            direction = [1, 0]\n+        else:\n+            direction = [dx / dist, dy / dist]\n+\n+        # Create the projectile\n+        projectile = KamehamehaProjectile(\n+            x=owner_x,\n+            y=owner_y,\n+            direction=direction,\n+            damage=self.damage,\n+            owner_id=owner_id\n+        )\n+        \n+        # Most weapons return a list of projectiles\n+        return [projectile]\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"\n+        Custom draw method for the weapon pickup: looks like a glowing energy orb/gauntlet.\n+        \"\"\"\n+        if self.is_equipped:\n+            return\n+\n+        # World (Y-up) to Screen (Y-down)\n+        py_y = arena_height - self.location[1] - self.height\n+        center_x = self.location[0] + self.width // 2\n+        center_y = py_y + self.height // 2\n+\n+        # Animated pulse effect\n+        pulse = (math.sin(time.time() * 5) + 1) / 2  # 0 to 1\n+        glow_radius = 15 + (10 * pulse)\n+        \n+        # Draw glow\n+        glow_surf = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)\n+        pygame.draw.circle(glow_surf, (100, 200, 255, 100), (int(glow_radius), int(glow_radius)), int(glow_radius))\n+        screen.blit(glow_surf, (center_x - glow_radius, center_y - glow_radius))\n+\n+        # Draw core orb\n+        pygame.draw.circle(screen, (255, 255, 255), (int(center_x), int(center_y)), 8)\n+        pygame.draw.circle(screen, (0, 150, 255), (int(center_x), int(center_y)), 10, 2)\n+\n+        # Draw name\n+        super().draw(screen, arena_height)"
    }
  ]
}