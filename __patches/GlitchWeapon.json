{"name_of_backup": "20260104161653_GameFolder", "changes": [{"path": "GameFolder/platforms/GAME_platform.py", "diff": "--- a/GameFolder/platforms/GAME_platform.py\n+++ b/GameFolder/platforms/GAME_platform.py\n@@ -1,6 +1,7 @@\n from BASE_components.BASE_platform import BasePlatform\n import pygame\n import math\n+import random\n \n class Platform(BasePlatform):\n     def __init__(self, x: float, y: float, width: float, height: float, color=(50, 200, 50)):\n@@ -11,6 +12,28 @@\n         self.original_x = float(x)\n         self.original_y = float(y)\n         self.being_pulled = False\n+        self.is_solid = True\n+        self.glitch_timer = 0.0\n+        self.original_color = color\n+\n+    def update(self, delta_time: float):\n+        if self.glitch_timer > 0:\n+            self.glitch_timer -= delta_time\n+            if self.glitch_timer <= 0:\n+                self.glitch_timer = 0\n+                self.is_solid = True\n+                self.color = self.original_color\n+            else:\n+                self.is_solid = False\n+                # Flicker effect: swap between original color and a transparent/bright version\n+                if random.random() > 0.5:\n+                    self.color = (255, 255, 255) # Glitch flicker color\n+                else:\n+                    self.color = self.original_color\n+        else:\n+            self.glitch_timer = 0\n+            self.is_solid = True\n+            self.color = self.original_color\n \n     def draw(self, screen: pygame.Surface):\n         # EXAMPLE: Add a small border to the platform\n"}, {"path": "GameFolder/characters/GAME_character.py", "diff": "--- a/GameFolder/characters/GAME_character.py\n+++ b/GameFolder/characters/GAME_character.py\n@@ -84,12 +84,54 @@\n         if not self.is_alive:\n             return\n \n-        # Gradually recover multipliers\n-        if self.speed_multiplier < 1.0:\n-            self.speed_multiplier = min(1.0, self.speed_multiplier + 0.5 * delta_time)\n+        # Gradually recover speed multiplier (towards 1.0)\n+        if self.speed_multiplier != 1.0:\n+            if self.speed_multiplier < 1.0:\n+                self.speed_multiplier = min(1.0, self.speed_multiplier + 0.2 * delta_time)\n+            else:\n+                self.speed_multiplier = max(1.0, self.speed_multiplier - 0.2 * delta_time)\n+\n+        # Gradually recover scale ratio (towards 1.0)\n+        if self.scale_ratio != 1.0:\n+            if self.scale_ratio < 1.0:\n+                self.scale_ratio = min(1.0, self.scale_ratio + 0.1 * delta_time)\n+            else:\n+                self.scale_ratio = max(1.0, self.scale_ratio - 0.1 * delta_time)\n \n         if self.jump_height_multiplier < 1.0:\n             self.jump_height_multiplier = min(1.0, self.jump_height_multiplier + 0.5 * delta_time)\n+\n+    def apply_gravity(self, arena_height: float = 600, platforms: list = None):\n+        if not self.is_alive:\n+            return\n+\n+        if self.can_fly and self.vertical_velocity == 0:\n+            return\n+\n+        self.location[1] += self.vertical_velocity\n+        self.vertical_velocity -= self.gravity * self.gravity_multiplier\n+\n+        if self.location[1] <= 0:\n+            self.location[1] = 0\n+            self.vertical_velocity = 0\n+            self.on_ground = True\n+            self.hover_time = 0\n+        else:\n+            self.on_ground = False\n+            if platforms and not self.is_dropping and self.vertical_velocity <= 0:\n+                char_rect = self.get_rect()\n+                py_feet_y = arena_height - self.location[1]\n+                for plat in platforms:\n+                    if not getattr(plat, 'is_solid', True):\n+                        continue\n+                    overlap = py_feet_y - plat.rect.top\n+                    if 0 <= overlap < 20:\n+                        if self.location[0] + char_rect.width > plat.rect.left and self.location[0] < plat.rect.right:\n+                            self.location[1] = arena_height - plat.rect.top\n+                            self.vertical_velocity = 0\n+                            self.on_ground = True\n+                            self.hover_time = 0\n+                            break\n \n     def draw(self, screen: pygame.Surface, arena_height: float):\n         if not self.is_alive:\n"}, {"path": "GameFolder/projectiles/GlitchProjectile.py", "diff": "--- a/GameFolder/projectiles/GlitchProjectile.py\n+++ b/GameFolder/projectiles/GlitchProjectile.py\n@@ -0,0 +1,38 @@\n+import pygame\n+import random\n+from BASE_components.BASE_projectile import BaseProjectile\n+\n+class GlitchProjectile(BaseProjectile):\n+    def __init__(self, x: float, y: float, direction: [float, float], speed: float, damage: float, owner_id: str):\n+        super().__init__(x, y, direction, speed, damage, owner_id, width=15, height=15)\n+        self.color = (200, 50, 255)  # Glitch purple/magenta\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"\n+        Renders the projectile with a flickering 'glitch' effect.\n+        Uses random colors and slight position offsets.\n+        \"\"\"\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1] - self.height\n+\n+        # Random offset for the 'flicker' effect\n+        offset_x = random.uniform(-3, 3)\n+        offset_y = random.uniform(-3, 3)\n+\n+        # Random color flicker\n+        if random.random() > 0.7:\n+            # Occasionally flash cyan or white\n+            draw_color = random.choice([(0, 255, 255), (255, 255, 255), (255, 0, 255)])\n+        else:\n+            draw_color = self.color\n+\n+        # Visual glitch: sometimes draw extra squares\n+        if random.random() > 0.8:\n+            ghost_rect = pygame.Rect(self.location[0] + offset_x * 2, py_y + offset_y * 2, self.width, self.height)\n+            pygame.draw.rect(screen, (100, 100, 100), ghost_rect, 1)\n+\n+        py_rect = pygame.Rect(self.location[0] + offset_x, py_y + offset_y, self.width, self.height)\n+        pygame.draw.rect(screen, draw_color, py_rect)"}, {"path": "GameFolder/weapons/GlitchGun.py", "diff": "--- a/GameFolder/weapons/GlitchGun.py\n+++ b/GameFolder/weapons/GlitchGun.py\n@@ -0,0 +1,38 @@\n+import pygame\n+import time\n+import math\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.GlitchProjectile import GlitchProjectile\n+\n+class GlitchGun(Weapon):\n+    def __init__(self, location=None):\n+        super().__init__(\n+            name=\"Glitch Gun\",\n+            damage=5.0,\n+            cooldown=0.4,\n+            projectile_speed=25.0,\n+            location=location\n+        )\n+        self.color = (200, 50, 255)  # Distinctive magenta/purple\n+        self.width = 45\n+        self.height = 30\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"\n+        Shoots a GlitchProjectile towards the target.\n+        \"\"\"\n+        if not self.can_shoot():\n+            return None\n+\n+        self.last_shot_time = time.time()\n+\n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+\n+        if dist == 0:\n+            direction = [1, 0]\n+        else:\n+            direction = [dx / dist, dy / dist]\n+\n+        return [GlitchProjectile(owner_x, owner_y, direction, self.projectile_speed, self.damage, owner_id)]"}, {"path": "GameFolder/setup.py", "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,7 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.GlitchGun import GlitchGun\n \n def setup_battle_arena():\n     \"\"\"\n@@ -41,10 +42,12 @@\n     \n     # Special weapons classes\n     arena.register_weapon_type(\"StormBringer\", StormBringer)\n-    arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n+    arena.register_weapon_type(\"Singularity Cannon\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"Glitch Gun\", GlitchGun)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(GlitchGun([600, 400]))\n     \n     return arena"}, {"path": "GameFolder/arenas/GAME_arena.py", "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,8 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.GlitchGun import GlitchGun\n+from GameFolder.projectiles.GlitchProjectile import GlitchProjectile\n import pygame\n import random\n import math\n@@ -23,9 +25,10 @@\n             self.platforms[0] = Platform(floor.rect.x, floor.rect.y, floor.rect.width, floor.rect.height, floor.color)\n             \n         # Register custom weapons\n-        self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n-        self.register_weapon_type(\"TornadoGun\", TornadoGun)\n-        self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"Singularity Cannon\", BlackHoleGun)\n+        self.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+        self.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n+        self.register_weapon_type(\"Glitch Gun\", GlitchGun)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +50,7 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, GlitchProjectile)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -227,6 +230,44 @@\n                     if char.location[0] < beam_x_max and char.location[0] + char_w > beam_x_min:\n                         char.take_damage(proj.damage * delta_time)\n             \n+            elif isinstance(proj, GlitchProjectile):\n+                # Collision with Platforms\n+                p_py_x = proj.location[0] - proj.width / 2\n+                p_py_y = (self.height - proj.location[1]) - proj.height / 2\n+                p_py_rect = pygame.Rect(p_py_x, p_py_y, proj.width, proj.height)\n+                \n+                for plat in self.platforms:\n+                    if p_py_rect.colliderect(plat.rect):\n+                        plat.glitch_timer = 3.0\n+                        proj.active = False\n+                        break\n+                \n+                # Collision with Characters\n+                if proj.active:\n+                    for char in self.characters:\n+                        if not char.is_alive or char.id == proj.owner_id:\n+                            continue\n+                        \n+                        char_w, char_h = char.width * char.scale_ratio, char.height * char.scale_ratio\n+                        char_rect = pygame.Rect(char.location[0], self.height - char.location[1] - char_h, char_w, char_h)\n+                        \n+                        if p_py_rect.colliderect(char_rect):\n+                            # Glitch Effects\n+                            char.scale_ratio = random.uniform(0.5, 1.5)\n+                            char.speed_multiplier = random.uniform(0.5, 2.0)\n+                            \n+                            # Teleportation offset\n+                            tele_x = random.uniform(-50, 50)\n+                            tele_y = random.uniform(-50, 50)\n+                            char.location[0] += tele_x\n+                            char.location[1] += tele_y\n+                            \n+                            # Standard damage\n+                            char.take_damage(proj.damage)\n+                            \n+                            proj.active = False\n+                            break\n+            \n             # Put persistent projectile back into active list\n             if proj.active:\n                 self.projectiles.append(proj)\n@@ -240,6 +281,10 @@\n         for plat in self.platforms[1:]: # Skip floor\n             if not getattr(plat, 'being_pulled', False):\n                 plat.return_to_origin(delta_time)\n+\n+        # Ensure platforms update (decrement glitch timers)\n+        for plat in self.platforms:\n+            plat.update(delta_time)\n \n     def run(self):\n         \"\"\"\n"}, {"path": "GameFolder/tests/glitch_gun_tests.py", "diff": "--- a/GameFolder/tests/glitch_gun_tests.py\n+++ b/GameFolder/tests/glitch_gun_tests.py\n@@ -0,0 +1,169 @@\n+import pygame\n+import time\n+import random\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.platforms.GAME_platform import Platform\n+from GameFolder.weapons.GlitchGun import GlitchGun\n+from GameFolder.projectiles.GlitchProjectile import GlitchProjectile\n+\n+def test_glitch_gun_projectile_spawn():\n+    \"\"\"Verify GlitchGun returns a GlitchProjectile with correct stats.\"\"\"\n+    weapon = GlitchGun()\n+    projs = weapon.shoot(100, 100, 200, 100, \"owner_1\")\n+    assert projs is not None\n+    assert len(projs) == 1\n+    assert isinstance(projs[0], GlitchProjectile)\n+    assert projs[0].owner_id == \"owner_1\"\n+    assert projs[0].damage == 5.0\n+\n+def test_glitch_projectile_damage():\n+    \"\"\"Verify GlitchProjectile deals damage to a character.\"\"\"\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    arena.add_character(shooter)\n+    arena.add_character(target)\n+    \n+    initial_health = target.health\n+    # Target is at 200, 100. Height 50. Rect top (pygame) is 600 - 100 - 50 = 450.\n+    # Projectile at 225, 125 (world y) center of target.\n+    proj = GlitchProjectile(225, 125, [0, 0], 0, 5.0, shooter.id)\n+    arena.projectiles.append(proj)\n+    \n+    # Handle collisions\n+    arena.handle_collisions(0.016)\n+    \n+    assert target.health < initial_health, \"Target should take damage\"\n+    assert not proj.active, \"Projectile should be deactivated on hit\"\n+\n+def test_glitch_projectile_character_effects():\n+    \"\"\"Verify GlitchProjectile applies random scale, speed, and teleportation.\"\"\"\n+    arena = Arena(800, 600)\n+    shooter = Character(\"Shooter\", \"\", \"\", [100, 100])\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    arena.add_character(shooter)\n+    arena.add_character(target)\n+    \n+    initial_scale = target.scale_ratio\n+    initial_speed_mult = target.speed_multiplier\n+    initial_loc = list(target.location)\n+    \n+    # Use fixed seed for deterministic test if possible, but changes are enough\n+    random.seed(42)\n+    proj = GlitchProjectile(225, 125, [0, 0], 0, 5.0, shooter.id)\n+    arena.projectiles.append(proj)\n+    \n+    arena.handle_collisions(0.016)\n+    \n+    assert target.scale_ratio != initial_scale, \"Scale ratio should change\"\n+    assert target.speed_multiplier != initial_speed_mult, \"Speed multiplier should change\"\n+    assert target.location != initial_loc, \"Location should change (teleport)\"\n+\n+def test_glitch_projectile_platform_glitch():\n+    \"\"\"Verify hitting a platform sets glitch_timer and makes it non-solid.\"\"\"\n+    arena = Arena(800, 600)\n+    plat = Platform(200, 300, 100, 20)\n+    arena.add_platform(plat)\n+    \n+    # Platform py_rect: [200, 300, 100, 20]\n+    # World Y center: 600 - (300 + 10) = 290\n+    proj = GlitchProjectile(250, 290, [0, 0], 0, 5.0, \"owner_1\")\n+    arena.projectiles.append(proj)\n+    \n+    assert plat.is_solid == True\n+    assert plat.glitch_timer == 0\n+    \n+    arena.handle_collisions(0.016)\n+    \n+    assert 2.9 <= plat.glitch_timer <= 3.0, \"Glitch timer should be set to 3.0\"\n+    assert plat.is_solid == False, \"Platform should be non-solid while glitched\"\n+    assert not proj.active, \"Projectile should be deactivated\"\n+\n+def test_platform_glitch_timer_decrements():\n+    \"\"\"Verify platform glitch timer counts down and restores state.\"\"\"\n+    plat = Platform(0, 0, 100, 20)\n+    plat.glitch_timer = 1.0\n+    plat.update(0.5)\n+    assert abs(plat.glitch_timer - 0.5) < 1e-6\n+    assert plat.is_solid == False\n+    \n+    plat.update(0.6)\n+    assert plat.glitch_timer <= 0\n+    assert plat.is_solid == True\n+\n+def test_character_glitch_recovery():\n+    \"\"\"Verify character recovers from glitch effects over time.\"\"\"\n+    char = Character(\"Test\", \"\", \"\", [100, 100])\n+    char.scale_ratio = 1.5\n+    char.speed_multiplier = 0.5\n+    \n+    # Recover for 1 second\n+    # Scale recovery: 0.1/s. 1.5 -> 1.4\n+    # Speed recovery: 0.2/s. 0.5 -> 0.7\n+    char.update(1.0)\n+    \n+    assert abs(char.scale_ratio - 1.4) < 0.001, f\"Expected 1.4, got {char.scale_ratio}\"\n+    assert abs(char.speed_multiplier - 0.7) < 0.001, f\"Expected 0.7, got {char.speed_multiplier}\"\n+    \n+    # Recover fully\n+    char.update(10.0)\n+    assert char.scale_ratio == 1.0\n+    assert char.speed_multiplier == 1.0\n+\n+def test_character_falls_through_glitched_platform():\n+    \"\"\"Verify character falls through a glitched platform.\"\"\"\n+    arena = Arena(800, 600)\n+    # Platform at y=100 (py_rect top). World Y = 500\n+    plat = Platform(100, 100, 200, 20)\n+    arena.add_platform(plat)\n+    \n+    char = Character(\"Test\", \"\", \"\", [150, 500])\n+    char.on_ground = True\n+    arena.add_character(char)\n+    \n+    # Initially on ground\n+    char.apply_gravity(600, arena.platforms)\n+    assert char.on_ground == True\n+    assert char.location[1] == 500\n+    \n+    # Glitch the platform\n+    plat.glitch_timer = 3.0\n+    plat.update(0) # trigger is_solid = False\n+    assert plat.is_solid == False\n+    \n+    # Apply gravity/update - should fall\n+    char.velocity[1] = -10 # ensure it moves down\n+    char.update(0.1, arena.platforms, 600)\n+    assert char.on_ground == False\n+    assert char.location[1] < 500\n+\n+def test_glitch_gun_registration():\n+    \"\"\"Verify Glitch Gun is registered in the arena lootpool.\"\"\"\n+    arena = Arena(800, 600)\n+    assert \"Glitch Gun\" in arena.lootpool\n+    \n+    # Check it creates the right weapon\n+    weapon = arena.lootpool[\"Glitch Gun\"]([100, 100])\n+    assert isinstance(weapon, GlitchGun)\n+\n+def test_glitch_gun_cooldown():\n+    \"\"\"Verify Glitch Gun respects cooldown.\"\"\"\n+    weapon = GlitchGun()\n+    assert weapon.can_shoot() == True\n+    weapon.shoot(0, 0, 10, 0, \"owner\")\n+    assert weapon.can_shoot() == False\n+    time.sleep(0.5) # Cooldown is 0.4\n+    assert weapon.can_shoot() == True\n+\n+def test_glitch_projectile_hits_floor():\n+    \"\"\"Verify GlitchProjectile deactivates on floor platform hit.\"\"\"\n+    arena = Arena(800, 600)\n+    # Floor is platforms[0]\n+    floor = arena.platforms[0]\n+    # Projectile at floor level (world y=0 approx)\n+    proj = GlitchProjectile(floor.rect.centerx, 0, [0, 0], 0, 5.0, \"owner\")\n+    arena.projectiles.append(proj)\n+    arena.handle_collisions(0.016)\n+    assert 2.9 <= floor.glitch_timer <= 3.0\n+    assert not proj.active"}, {"path": "GameFolder/tests/storm_tests.py", "diff": "--- a/GameFolder/tests/storm_tests.py\n+++ b/GameFolder/tests/storm_tests.py\n@@ -88,7 +88,7 @@\n     char.update(0.5)\n     assert char.speed_multiplier > 0.4, \"Multiplier should start recovering\"\n     \n-    char.update(2.0)\n+    char.update(3.0)\n     assert char.speed_multiplier == 1.0, \"Multiplier should fully recover to 1.0\"\n \n def test_jump_multiplier_recovery():\n"}]}