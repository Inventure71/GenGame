{
  "name_of_backup": "20260104161653_GameFolder",
  "changes": [
    {
      "path": "GameFolder/arenas/GAME_arena.py",
      "diff": "--- a/GameFolder/arenas/GAME_arena.py\n+++ b/GameFolder/arenas/GAME_arena.py\n@@ -10,6 +10,14 @@\n from GameFolder.projectiles.TornadoProjectile import TornadoProjectile\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.projectiles.OrbitalProjectiles import TargetingLaser, OrbitalStrikeMarker, OrbitalBlast\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n+\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n import pygame\n import random\n import math\n@@ -26,6 +34,12 @@\n         self.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n         self.register_weapon_type(\"TornadoGun\", TornadoGun)\n         self.register_weapon_type(\"OrbitalCannon\", OrbitalCannon)\n+        self.register_weapon_type(\"CatRainGun\", CatRainGun)\n+\n+        self.register_weapon_type(\"KamehamehaGun\", KamehamehaGun)\n         \n         # Custom aesthetics\n         pygame.display.set_caption(\"GenGame - Battle Arena\")\n@@ -47,7 +61,12 @@\n \n         for p in self.projectiles:\n             # Persistent and phase projectiles\n-            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast)):\n+            if isinstance(p, (BlackHoleProjectile, TornadoProjectile, TargetingLaser, OrbitalStrikeMarker, OrbitalBlast, CatCloud, KamehamehaProjectile)):\n                 special_projs.append(p)\n             elif isinstance(p, StormCloud) and p.is_raining:\n                 special_projs.append(p)\n@@ -141,6 +160,13 @@\n                             if dist < 50:\n                                 char.take_damage(proj.damage * delta_time * 60)\n             \n+            \n+            elif isinstance(proj, CatCloud) and proj.is_raining:\n+                # IMPORTANT: In this custom loop, self.projectiles is standard_projs\n+                # We must add to standard_projs so they are handled by super().handle_collisions\n+                # OR add to self.projectiles AFTER the loop, but here special_projs are NOT in self.projectiles.\n+                new_cats = proj.spawn_cats(delta_time)\n+                standard_projs.extend(new_cats)\n             \n             elif isinstance(proj, TornadoProjectile):\n                 # Conical pull logic: wider at top, pulls characters, weapons, and platforms\n@@ -227,6 +253,56 @@\n                     if char.location[0] < beam_x_max and char.location[0] + char_w > beam_x_min:\n                         char.take_damage(proj.damage * delta_time)\n             \n+            elif isinstance(proj, KamehamehaProjectile):\n+                # Find owner to anchor and apply recoil\n+                owner = next((c for c in self.characters if c.id == proj.owner_id), None)\n+                if owner and owner.is_alive:\n+                    # Anchor to owner center\n+                    owner_center_x = owner.location[0] + (owner.width * owner.scale_ratio) / 2\n+                    owner_center_y = owner.location[1] + (owner.height * owner.scale_ratio) / 2\n+                    proj.location = [owner_center_x, owner_center_y]\n+                    \n+                    if proj.state == 'FIRING':\n+                        # Apply recoil to owner (push away from beam direction)\n+                        recoil_strength = 250.0 # units per second\n+                        owner.location[0] -= proj.direction[0] * recoil_strength * delta_time\n+                        owner.location[1] -= proj.direction[1] * recoil_strength * delta_time\n+                        \n+                        # Beam Collision Logic\n+                        for char in self.characters:\n+                            if not char.is_alive or char.id == proj.owner_id:\n+                                continue\n+                            \n+                            # Character center\n+                            c_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+                            c_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+                            \n+                            # Vector from beam start to character\n+                            dx = c_center_x - proj.location[0]\n+                            dy = c_center_y - proj.location[1]\n+                            \n+                            # Projection of (dx, dy) onto beam direction\n+                            dot = dx * proj.direction[0] + dy * proj.direction[1]\n+                            \n+                            # If character is in front of the beam and within beam length\n+                            if 0 <= dot <= proj.beam_length:\n+                                # Closest point on the line\n+                                closest_x = proj.location[0] + proj.direction[0] * dot\n+                                closest_y = proj.location[1] + proj.direction[1] * dot\n+                                \n+                                # Distance from character center to closest point\n+                                dist_sq = (c_center_x - closest_x)**2 + (c_center_y - closest_y)**2\n+                                hit_radius = 45 # Beam radius approx\n+                                \n+                                if dist_sq < hit_radius**2:\n+                                    # Apply continuous damage\n+                                    char.take_damage(proj.damage * delta_time)\n+                                    \n+                                    # Apply knockback (in direction of beam)\n+                                    knockback_force = 400.0\n+                                    char.location[0] += proj.direction[0] * knockback_force * delta_time\n+                                    char.location[1] += proj.direction[1] * knockback_force * delta_time\n+\n             # Put persistent projectile back into active list\n             if proj.active:\n                 self.projectiles.append(proj)"
    },
    {
      "path": "GameFolder/projectiles/CatProjectiles.py",
      "diff": "--- a/GameFolder/projectiles/CatProjectiles.py\n+++ b/GameFolder/projectiles/CatProjectiles.py\n@@ -0,0 +1,100 @@\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+import pygame\n+import math\n+import random\n+\n+class FallingCat(Projectile):\n+    def __init__(self, x, y, owner_id):\n+        # Direction: [0, -1] (World coordinates, moving down)\n+        # Size: ~20x20 pixels\n+        super().__init__(x, y, [0, -1], 10, 5, owner_id, 20, 20)\n+        self.color = (255, 165, 0)  # Orange\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1] - self.height\n+        py_rect = pygame.Rect(self.location[0], py_y, self.width, self.height)\n+\n+        # Body (orange ellipse)\n+        pygame.draw.ellipse(screen, self.color, py_rect)\n+\n+        # Ears (two small triangles)\n+        ear_color = self.color\n+        # Left ear\n+        le_p1 = (py_rect.left, py_rect.top + 5)\n+        le_p2 = (py_rect.left + 5, py_rect.top - 5)\n+        le_p3 = (py_rect.left + 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [le_p1, le_p2, le_p3])\n+\n+        # Right ear\n+        re_p1 = (py_rect.right, py_rect.top + 5)\n+        re_p2 = (py_rect.right - 5, py_rect.top - 5)\n+        re_p3 = (py_rect.right - 8, py_rect.top + 2)\n+        pygame.draw.polygon(screen, ear_color, [re_p1, re_p2, re_p3])\n+\n+class CatCloud(Projectile):\n+    def __init__(self, x, y, target_pos, owner_id):\n+        # Travels to a target position, then stays there for a duration (e.g., 5.0s)\n+        super().__init__(x, y, [0, 0], 12, 0, owner_id, 80, 40)\n+        self.target_pos = target_pos\n+        self.is_raining = False\n+        self.cat_spawn_timer = 0.0\n+        self.rain_duration = 5.0\n+        self.rain_timer = 0.0\n+        self.spawn_interval = 0.2\n+        self.persistent = True # Keep it alive in the arena\n+\n+    def update(self, delta_time):\n+        if self.is_raining:\n+            # Stationary and raining\n+            self.rain_timer += delta_time\n+            if self.rain_timer >= self.rain_duration:\n+                self.active = False\n+        else:\n+            # Move towards target_pos\n+            dx = self.target_pos[0] - self.location[0]\n+            dy = self.target_pos[1] - self.location[1]\n+            dist = math.hypot(dx, dy)\n+            move_dist = self.speed * (delta_time * 60)\n+\n+            if dist <= move_dist:\n+                self.location[0] = self.target_pos[0]\n+                self.location[1] = self.target_pos[1]\n+                self.is_raining = True\n+            else:\n+                self.location[0] += (dx / dist) * move_dist\n+                self.location[1] += (dy / dist) * move_dist\n+        \n+        # Do NOT call super().update() because it would move based on self.direction\n+        # and potentially move it off target.\n+\n+    def spawn_cats(self, delta_time):\n+        new_cats = []\n+        if self.is_raining and self.active:\n+            self.cat_spawn_timer += delta_time\n+            while self.cat_spawn_timer >= self.spawn_interval:\n+                # Spawn at random x within cloud width\n+                spawn_x = self.location[0] + random.uniform(0, self.width - 20)\n+                spawn_y = self.location[1] # Start from cloud bottom/center\n+                new_cats.append(FallingCat(spawn_x, spawn_y, self.owner_id))\n+                self.cat_spawn_timer -= self.spawn_interval\n+        return new_cats\n+\n+    def draw(self, screen, arena_height):\n+        if not self.active:\n+            return\n+\n+        py_y = arena_height - self.location[1] - self.height\n+        \n+        # Fluffy white/gray cloud (multiple ellipses)\n+        cloud_color = (240, 240, 240)\n+        rects = [\n+            pygame.Rect(self.location[0], py_y + 10, self.width, self.height - 10),\n+            pygame.Rect(self.location[0] + 10, py_y, self.width - 20, self.height),\n+            pygame.Rect(self.location[0] + 20, py_y - 5, self.width - 40, self.height - 10)\n+        ]\n+        for r in rects:\n+            pygame.draw.ellipse(screen, cloud_color, r)"
    },
    {
      "path": "GameFolder/projectiles/KamehamehaProjectile.py",
      "diff": "--- a/GameFolder/projectiles/KamehamehaProjectile.py\n+++ b/GameFolder/projectiles/KamehamehaProjectile.py\n@@ -0,0 +1,105 @@\n+import pygame\n+import math\n+import random\n+from GameFolder.projectiles.GAME_projectile import Projectile\n+\n+class KamehamehaProjectile(Projectile):\n+    def __init__(self, x: float, y: float, direction: list, owner_id: str, damage: float):\n+        # Initialize with speed 0 because it's anchored to owner or behaves like a beam\n+        super().__init__(x, y, direction, 0, damage, owner_id, width=40, height=40)\n+        self.state = 'CHARGING'\n+        self.timer = 0.0\n+        self.charge_duration = 1.2\n+        self.fire_duration = 1.5\n+        self.beam_length = 2000 # Large enough to cross arena\n+        self.pulse_timer = 0.0\n+        \n+        # For visual effects\n+        self.charge_particles = []\n+        for _ in range(12):\n+            self.charge_particles.append({\n+                'angle': random.uniform(0, math.pi * 2),\n+                'dist': random.uniform(30, 60),\n+                'speed': random.uniform(1, 3)\n+            })\n+\n+    def update(self, delta_time: float):\n+        self.timer += delta_time\n+        self.pulse_timer += delta_time\n+        \n+        if self.state == 'CHARGING':\n+            if self.timer >= self.charge_duration:\n+                self.state = 'FIRING'\n+                self.timer = 0.0\n+            \n+            # Update charge particles\n+            for p in self.charge_particles:\n+                p['dist'] -= p['speed'] * (delta_time * 60)\n+                if p['dist'] < 5:\n+                    p['dist'] = random.uniform(40, 70)\n+                    p['angle'] = random.uniform(0, math.pi * 2)\n+                    \n+        elif self.state == 'FIRING':\n+            if self.timer >= self.fire_duration:\n+                self.active = False\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        if not self.active:\n+            return\n+\n+        # Map y-up to pygame y-down\n+        py_y = arena_height - self.location[1]\n+        py_x = self.location[0]\n+\n+        if self.state == 'CHARGING':\n+            # Pulsing blue orb\n+            pulse = (math.sin(self.pulse_timer * 15) + 1) * 0.5\n+            radius = 15 + pulse * 10\n+            \n+            # Outer Glow\n+            pygame.draw.circle(screen, (0, 100, 255), (int(py_x), int(py_y)), int(radius + 5), 2)\n+            # Core\n+            pygame.draw.circle(screen, (200, 230, 255), (int(py_x), int(py_y)), int(radius))\n+            \n+            # Draw gathering particles\n+            for p in self.charge_particles:\n+                px = py_x + math.cos(p['angle']) * p['dist']\n+                py = py_y + math.sin(p['angle']) * p['dist']\n+                pygame.draw.circle(screen, (100, 200, 255), (int(px), int(py)), 3)\n+\n+        elif self.state == 'FIRING':\n+            # Beam visual\n+            flicker = random.randint(-5, 5)\n+            beam_width = 60 + flicker\n+            \n+            # Calculate end point based on direction\n+            end_x = py_x + self.direction[0] * self.beam_length\n+            end_y = py_y - self.direction[1] * self.beam_length # y-up logic to y-down screen\n+            \n+            # Draw beam layers\n+            # 1. Outer Glow\n+            pygame.draw.line(screen, (0, 150, 255), (py_x, py_y), (end_x, end_y), int(beam_width + 20))\n+            # 2. Main Blue\n+            pygame.draw.line(screen, (100, 200, 255), (py_x, py_y), (end_x, end_y), int(beam_width))\n+            # 3. White Core\n+            pygame.draw.line(screen, (255, 255, 255), (py_x, py_y), (end_x, end_y), int(beam_width // 2))\n+            \n+            # Flickering Orbs along the beam\n+            for i in range(10):\n+                dist_ratio = ( (self.pulse_timer * 2 + i/10.0) % 1.0 )\n+                bx = py_x + self.direction[0] * self.beam_length * dist_ratio\n+                by = py_y - self.direction[1] * self.beam_length * dist_ratio\n+                pygame.draw.circle(screen, (255, 255, 255), (int(bx), int(by)), random.randint(5, 15))\n+\n+            # Start Orb\n+            pygame.draw.circle(screen, (200, 230, 255), (int(py_x), int(py_y)), int(beam_width // 1.2))\n+\n+    def get_rect(self) -> pygame.Rect:\n+        # For the beam, the 'rect' is tricky. \n+        # Usually collisions are handled by the arena for beams, \n+        # but we'll return a representative rect of the firing point for now.\n+        if self.state == 'FIRING':\n+            # Large bounding box for simple logic or specific beam collision logic in Arena\n+            return pygame.Rect(self.location[0] - 50, self.location[1] - 50, 100, 100)\n+        else:\n+            return pygame.Rect(self.location[0] - 20, self.location[1] - 20, 40, 40)"
    },
    {
      "path": "GameFolder/setup.py",
      "diff": "--- a/GameFolder/setup.py\n+++ b/GameFolder/setup.py\n@@ -6,6 +6,12 @@\n from GameFolder.weapons.BlackHoleGun import BlackHoleGun\n from GameFolder.weapons.OrbitalCannon import OrbitalCannon\n from GameFolder.weapons.TornadoGun import TornadoGun\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n \n def setup_battle_arena():\n     \"\"\"\n@@ -44,7 +50,19 @@\n     arena.register_weapon_type(\"BlackHoleGun\", BlackHoleGun)\n     arena.register_weapon_type(\"Orbital Cannon\", OrbitalCannon)\n     arena.register_weapon_type(\"Tornado Launcher\", TornadoGun)\n+    arena.register_weapon_type(\"Cat Rain Gun\", CatRainGun)\n+\n+    arena.register_weapon_type(\"Kamehameha Gun\", KamehamehaGun)\n \n     arena.spawn_weapon(OrbitalCannon([100, 100]))\n+    arena.spawn_weapon(CatRainGun([600, 400]))\n+\n+    arena.spawn_weapon(KamehamehaGun([600, 400]))\n     \n     return arena"
    },
    {
      "path": "GameFolder/tests/cat_rain_tests.py",
      "diff": "--- a/GameFolder/tests/cat_rain_tests.py\n+++ b/GameFolder/tests/cat_rain_tests.py\n@@ -0,0 +1,172 @@\n+import math\n+import pygame\n+import pytest\n+from GameFolder.weapons.CatRainGun import CatRainGun\n+from GameFolder.projectiles.CatProjectiles import CatCloud, FallingCat\n+from GameFolder.arenas.GAME_arena import Arena\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.setup import setup_battle_arena\n+\n+def test_cat_rain_gun_properties():\n+    \"\"\"Verify CatRainGun initial properties.\"\"\"\n+    gun = CatRainGun()\n+    assert gun.name == \"Cat Rain Gun\"\n+    assert gun.cooldown == 5.0\n+    assert gun.color == (255, 165, 0)\n+\n+def test_cat_rain_gun_shooting():\n+    \"\"\"Verify CatRainGun spawns a CatCloud.\"\"\"\n+    gun = CatRainGun()\n+    gun.last_shot_time = 0 \n+    cloud = gun.shoot(100, 100, 200, 300, \"player1\")\n+    assert isinstance(cloud, CatCloud)\n+    assert cloud.target_pos == [200, 300]\n+    assert cloud.owner_id == \"player1\"\n+\n+def test_cat_cloud_movement():\n+    \"\"\"Verify CatCloud moves towards target then starts raining.\"\"\"\n+    # Start at 100,100 target 200,100. Speed 12.\n+    cloud = CatCloud(100, 100, [200, 100], \"player1\")\n+    assert not cloud.is_raining\n+    \n+    # Move partway. Speed=12, dt=0.1. move_dist = 12 * (0.1*60) = 72.\n+    cloud.update(0.1) \n+    assert cloud.location[0] == 172\n+    assert not cloud.is_raining\n+    \n+    # Move to target. Remaining dist = 28. Next move will be 72, which is > 28.\n+    cloud.update(0.1)\n+    assert cloud.is_raining, \"Cloud should be raining after reaching target\"\n+    assert cloud.location == [200, 100]\n+\n+def test_cat_cloud_spawning():\n+    \"\"\"Verify CatCloud spawns FallingCat projectiles when raining.\"\"\"\n+    cloud = CatCloud(200, 400, [200, 400], \"player1\")\n+    cloud.is_raining = True\n+    cloud.active = True\n+    \n+    # spawn_interval is 0.2\n+    cats = cloud.spawn_cats(0.1)\n+    assert len(cats) == 0\n+    \n+    cats = cloud.spawn_cats(0.15)\n+    assert len(cats) == 1\n+    assert isinstance(cats[0], FallingCat)\n+    assert cats[0].owner_id == \"player1\"\n+    # Spawned at cloud x (200) to 200+width-20 (200+80-20=260)\n+    assert 200 <= cats[0].location[0] <= 260\n+    assert cats[0].location[1] == 400\n+\n+def test_falling_cat_movement():\n+    \"\"\"Verify FallingCat moves downwards.\"\"\"\n+    cat = FallingCat(200, 400, \"player1\")\n+    # Speed 10, Direction [0, -1].\n+    # move_dist = 10 * (0.1 * 60) = 60.\n+    cat.update(0.1)\n+    assert cat.location[1] == 400 - 60\n+    assert cat.location[0] == 200\n+\n+def test_falling_cat_deals_damage():\n+    \"\"\"Verify FallingCat deals damage on collision in Arena.\"\"\"\n+    arena = Arena(800, 600)\n+    target = Character(\"Target\", \"\", \"\", [200, 100])\n+    target.id = \"target\"\n+    target.defense = 0\n+    arena.characters.append(target)\n+    \n+    # Cat falling right on target.\n+    # Character is at [200, 100], width 45.\n+    # Cat is at [210, 150], width 20.\n+    cat = FallingCat(210, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    initial_health = target.health\n+    \n+    # Run arena until collision\n+    # Cat speed 10. dist to target top is roughly 50.\n+    for _ in range(10):\n+        arena.handle_collisions(0.016)\n+        if target.health < initial_health:\n+            break\n+            \n+    assert target.health < initial_health\n+    assert target.health == initial_health - cat.damage\n+    assert not cat.active\n+\n+def test_cat_cloud_duration():\n+    \"\"\"Verify CatCloud deactivates after rain duration.\"\"\"\n+    cloud = CatCloud(100, 100, [100, 100], \"player1\")\n+    cloud.is_raining = True\n+    cloud.rain_timer = 0\n+    \n+    cloud.update(cloud.rain_duration - 0.1)\n+    assert cloud.active\n+    \n+    cloud.update(0.2)\n+    assert not cloud.active\n+\n+def test_cat_rain_gun_registration():\n+    \"\"\"Verify CatRainGun is registered in setup_battle_arena.\"\"\"\n+    arena = setup_battle_arena()\n+    # Check lootpool\n+    assert \"Cat Rain Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Cat Rain Gun\"] == CatRainGun\n+    \n+    # Check if one was spawned (as per setup.py)\n+    found = False\n+    for w in arena.weapon_pickups:\n+        if isinstance(w, CatRainGun):\n+            found = True\n+            break\n+    assert found, \"Cat Rain Gun should be spawned in the arena\"\n+\n+def test_integration_cat_cloud_in_arena():\n+    \"\"\"Verify CatCloud spawns cats inside the Arena update loop.\"\"\"\n+    arena = Arena(800, 600)\n+    cloud = CatCloud(200, 500, [200, 500], \"player1\")\n+    cloud.is_raining = True\n+    arena.projectiles.append(cloud)\n+    \n+    # Run for 0.5s. With spawn_interval 0.2, should spawn at least 2 cats.\n+    # handle_collisions(0.1) called 5 times.\n+    for _ in range(5):\n+        arena.handle_collisions(0.1)\n+        \n+    # Check if cats exist in arena.projectiles\n+    # Note: they might have fallen off or been removed if they hit floor, \n+    # but at speed 10, in 0.5s they move 10*60*0.5 = 300. \n+    # Starting at 500, they would be at 200. Floor is usually at 120 or 0.\n+    \n+    cats = [p for p in arena.projectiles if isinstance(p, FallingCat)]\n+    assert len(cats) >= 2\n+    assert cloud in arena.projectiles\n+\n+def test_falling_cat_hits_platform():\n+    \"\"\"Verify FallingCat is deactivated when hitting a platform.\"\"\"\n+    arena = Arena(800, 600)\n+    # Platform at Screen Y=500, Height 20. \n+    # World Y = 600 - 500 - 20 = 80.\n+    from GameFolder.platforms.GAME_platform import Platform\n+    plat = Platform(100, 500, 200, 20)\n+    arena.add_platform(plat)\n+    \n+    # Cat above platform\n+    cat = FallingCat(150, 150, \"shooter\")\n+    arena.projectiles.append(cat)\n+    \n+    # Move cat down to hit platform\n+    for _ in range(20):\n+        arena.handle_collisions(0.016)\n+        if not cat.active:\n+            break\n+            \n+    assert not cat.active, \"Cat should deactivate on hitting platform\"\n+\n+def test_cat_cloud_diagonal_movement():\n+    \"\"\"Verify CatCloud moves correctly on diagonal path.\"\"\"\n+    cloud = CatCloud(0, 0, [100, 100], \"player1\")\n+    cloud.update(0.1) # move_dist = 72\n+    # Diagonal distance 141.4. move_dist 72.\n+    # move_x = (100/141.4) * 72 = 0.707 * 72 = 50.9\n+    assert 50 < cloud.location[0] < 52\n+    assert 50 < cloud.location[1] < 52"
    },
    {
      "path": "GameFolder/tests/kamehameha_tests.py",
      "diff": "--- a/GameFolder/tests/kamehameha_tests.py\n+++ b/GameFolder/tests/kamehameha_tests.py\n@@ -0,0 +1,203 @@\n+\"\"\"\n+Tests for Kamehameha Weapon and Projectile\n+\"\"\"\n+import pytest\n+import math\n+from GameFolder.characters.GAME_character import Character\n+from GameFolder.weapons.KamehamehaGun import KamehamehaGun\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n+from GameFolder.arenas.GAME_arena import Arena\n+\n+def test_kamehameha_gun_creation():\n+    \"\"\"Test that the Kamehameha gun initializes with correct values.\"\"\"\n+    gun = KamehamehaGun(location=[100, 100])\n+    assert gun.name == \"Kamehameha\"\n+    assert gun.damage == 50.0\n+    assert gun.cooldown == 5.0\n+    assert gun.location == [100, 100]\n+\n+def test_kamehameha_gun_shooting():\n+    \"\"\"Test that shooting returns a KamehamehaProjectile and triggers cooldown.\"\"\"\n+    gun = KamehamehaGun()\n+    # Initial shot should succeed\n+    projs = gun.shoot(owner_x=100, owner_y=100, target_x=200, target_y=100, owner_id=\"test_owner\")\n+    assert projs is not None\n+    assert len(projs) == 1\n+    assert isinstance(projs[0], KamehamehaProjectile)\n+    assert projs[0].owner_id == \"test_owner\"\n+    \n+    # Immediate second shot should fail due to cooldown\n+    projs2 = gun.shoot(owner_x=100, owner_y=100, target_x=200, target_y=100, owner_id=\"test_owner\")\n+    assert projs2 is None\n+\n+def test_kamehameha_projectile_states():\n+    \"\"\"Test that the Kamehameha projectile transitions through its states correctly.\"\"\"\n+    proj = KamehamehaProjectile(x=100, y=100, direction=[1, 0], owner_id=\"owner\", damage=50.0)\n+    assert proj.state == 'CHARGING'\n+    assert proj.active\n+    \n+    # Update to nearly finish charging\n+    dt = 0.1\n+    total_time = 0.0\n+    while total_time < proj.charge_duration - 0.05:\n+        proj.update(dt)\n+        total_time += dt\n+        assert proj.state == 'CHARGING'\n+    \n+    # One more update to transition to FIRING\n+    proj.update(0.1)\n+    assert proj.state == 'FIRING'\n+    \n+    # Update through FIRING duration\n+    total_firing_time = 0.0\n+    while total_firing_time < proj.fire_duration - 0.05:\n+        proj.update(dt)\n+        total_firing_time += dt\n+        assert proj.state == 'FIRING'\n+        assert proj.active\n+        \n+    # Final update to deactivate\n+    proj.update(0.1)\n+    assert not proj.active\n+\n+def test_kamehameha_integration_anchoring_and_recoil():\n+    \"\"\"Test anchoring to owner and recoil application in the Arena.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    char = Character(\"Shooter\", \"char1\", \"char1\", [500, 500])\n+    arena.characters = [char]\n+    \n+    # Give shooter the gun\n+    gun = KamehamehaGun()\n+    char.weapon = gun\n+    \n+    # Shoot right\n+    projs = char.shoot([600, 500])\n+    arena.projectiles.extend(projs)\n+    proj = projs[0]\n+    \n+    # 1. CHARGING State - Anchoring check\n+    char.location = [550, 550] # Move character during charging\n+    arena.handle_collisions(0.1)\n+    \n+    # Projectile should follow character center\n+    char_center_x = char.location[0] + (char.width * char.scale_ratio) / 2\n+    char_center_y = char.location[1] + (char.height * char.scale_ratio) / 2\n+    assert proj.location[0] == char_center_x\n+    assert proj.location[1] == char_center_y\n+    \n+    # No recoil during charging\n+    assert char.location == [550, 550]\n+    \n+    # 2. Transition to FIRING\n+    for _ in range(15): # Step past 1.2s charge\n+        arena.handle_collisions(0.1)\n+    \n+    assert proj.state == 'FIRING'\n+    \n+    # 3. FIRING State - Recoil check\n+    initial_loc = list(char.location)\n+    arena.handle_collisions(0.1)\n+    \n+    # Character should be pushed LEFT if shooting RIGHT ([1, 0])\n+    # recoil_strength is 250 units/s. In 0.1s, should move 25 units.\n+    assert char.location[0] < initial_loc[0]\n+    assert math.isclose(char.location[0], initial_loc[0] - 25.0, abs_tol=0.1)\n+\n+def test_kamehameha_integration_beam_collision():\n+    \"\"\"Test beam collision detection and damage application in the Arena.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    shooter = Character(\"Shooter\", \"char1\", \"char1\", [100, 500])\n+    target = Character(\"Target\", \"char2\", \"char2\", [300, 500])\n+    arena.characters = [shooter, target]\n+    \n+    # Shoot right at target\n+    gun = KamehamehaGun()\n+    shooter.weapon = gun\n+    projs = shooter.shoot([400, 500])\n+    arena.projectiles.extend(projs)\n+    proj = projs[0]\n+    \n+    # Skip charging\n+    for _ in range(15):\n+        arena.handle_collisions(0.1)\n+    \n+    assert proj.state == 'FIRING'\n+    \n+    # Check damage and knockback\n+    initial_hp = target.hp\n+    initial_x = target.location[0]\n+    \n+    arena.handle_collisions(0.1)\n+    \n+    assert target.hp < initial_hp\n+    assert target.location[0] > initial_x # Knockback to the right\n+    \n+    # Test target out of beam radius (above)\n+    target.location = [300, 700] \n+    target.hp = 100\n+    initial_x = target.location[0]\n+    arena.handle_collisions(0.1)\n+    \n+    assert target.hp == 100 # No damage\n+    assert target.location[0] == initial_x # No knockback\n+\n+def test_kamehameha_edge_cases():\n+    \"\"\"Test firing from boundaries and corners.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    gun = KamehamehaGun()\n+    \n+    # Corner: Bottom-Left shooting Top-Right\n+    projs = gun.shoot(0, 0, 1000, 1000, \"owner\")\n+    proj = projs[0]\n+    assert math.isclose(proj.direction[0], 0.707, abs_tol=0.01)\n+    assert math.isclose(proj.direction[1], 0.707, abs_tol=0.01)\n+    \n+    # Boundary: Top edge shooting down\n+    projs = gun.shoot(500, 1000, 500, 0, \"owner\")\n+    proj = projs[0]\n+    assert proj.direction == [0, -1]\n+\n+def test_kamehameha_lootpool_registration():\n+    \"\"\"Test that KamehamehaGun is registered in the arena's lootpool.\"\"\"\n+    from GameFolder.setup import setup_battle_arena\n+    arena = setup_battle_arena()\n+    assert \"Kamehameha Gun\" in arena.lootpool\n+    assert arena.lootpool[\"Kamehameha Gun\"] == KamehamehaGun\n+\n+def test_kamehameha_owner_death():\n+    \"\"\"Test that projectile continues if owner dies (or behavior depends on implementation).\n+    In current Arena implementation, it checks `if owner and owner.is_alive`.\n+    If owner is dead, anchoring and recoil stop.\n+    \"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    shooter = Character(\"Shooter\", \"char1\", \"char1\", [100, 500])\n+    arena.characters = [shooter]\n+    proj = KamehamehaProjectile(100, 500, [1, 0], shooter.id, 50.0)\n+    arena.projectiles.append(proj)\n+    \n+    shooter.hp = 0 # Kill shooter\n+    arena.handle_collisions(0.1)\n+    \n+    # Should not crash, and proj location should not have changed if it didn't find owner\n+    assert proj.location == [100, 500]\n+\n+def test_kamehameha_origin_scenarios():\n+    \"\"\"Test firing from specific origins requested in instructions.\"\"\"\n+    arena = Arena(width=1000, height=1000)\n+    gun = KamehamehaGun()\n+    \n+    # 1. Center\n+    projs = gun.shoot(500, 500, 600, 500, \"owner\")\n+    assert projs[0].location == [500, 500]\n+    \n+    # 2. Close to another character\n+    shooter = Character(\"S\", \"s\", \"s\", [500, 500])\n+    target = Character(\"T\", \"t\", \"t\", [510, 500]) # 10 units away\n+    arena.characters = [shooter, target]\n+    shooter.weapon = gun\n+    projs = shooter.shoot([510, 500])\n+    arena.projectiles.extend(projs)\n+    \n+    # Move to firing state\n+    for _ in range(15): arena.handle_collisions(0.1)\n+    assert target.hp < 100, \"Target very close to shooter should be hit immediately by beam\""
    },
    {
      "path": "GameFolder/weapons/CatRainGun.py",
      "diff": "--- a/GameFolder/weapons/CatRainGun.py\n+++ b/GameFolder/weapons/CatRainGun.py\n@@ -0,0 +1,18 @@\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.CatProjectiles import CatCloud\n+\n+class CatRainGun(Weapon):\n+    def __init__(self, location=None):\n+        # Name, damage (applied by spawned cats), cooldown, speed, location\n+        # Damage here is representative, actual damage depends on FallingCat.\n+        # Cooldown 5.0s as requested.\n+        super().__init__(\"Cat Rain Gun\", 5, 5.0, 12, location)\n+        self.color = (255, 165, 0)  # Orange like a ginger cat\n+\n+    def shoot(self, owner_x, owner_y, target_x, target_y, owner_id):\n+        \"\"\"\n+        Shoots a CatCloud projectile targeting the target location.\n+        \"\"\"\n+        target_pos = [target_x, target_y]\n+        # Create the CatCloud at the owner's position, heading to target_pos\n+        return CatCloud(owner_x, owner_y, target_pos, owner_id)"
    },
    {
      "path": "GameFolder/weapons/KamehamehaGun.py",
      "diff": "--- a/GameFolder/weapons/KamehamehaGun.py\n+++ b/GameFolder/weapons/KamehamehaGun.py\n@@ -0,0 +1,78 @@\n+import pygame\n+import math\n+import time\n+from GameFolder.weapons.GAME_weapon import Weapon\n+from GameFolder.projectiles.KamehamehaProjectile import KamehamehaProjectile\n+\n+class KamehamehaGun(Weapon):\n+    def __init__(self, location: [float, float] = None):\n+        # Long cooldown (5 seconds) and high base damage (50)\n+        # Note: Actual damage is applied per-frame in the arena logic during the FIRING state.\n+        super().__init__(\n+            name=\"Kamehameha\",\n+            damage=50.0,\n+            cooldown=5.0,\n+            projectile_speed=0.0,  # The beam doesn't 'travel' in a traditional sense\n+            location=location\n+        )\n+        self.color = (0, 191, 255)  # Deep Sky Blue\n+        self.width = 40\n+        self.height = 30\n+\n+    def shoot(self, owner_x: float, owner_y: float, target_x: float, target_y: float, owner_id: str):\n+        \"\"\"\n+        Returns a KamehamehaProjectile which handles its own state (CHARGING then FIRING).\n+        \"\"\"\n+        if not self.can_shoot():\n+            return None\n+\n+        self.last_shot_time = time.time()\n+\n+        # Calculate direction\n+        dx = target_x - owner_x\n+        dy = target_y - owner_y\n+        dist = math.hypot(dx, dy)\n+        if dist == 0:\n+            direction = [1, 0]\n+        else:\n+            direction = [dx / dist, dy / dist]\n+\n+        # Create the projectile\n+        projectile = KamehamehaProjectile(\n+            x=owner_x,\n+            y=owner_y,\n+            direction=direction,\n+            damage=self.damage,\n+            owner_id=owner_id\n+        )\n+        \n+        # Most weapons return a list of projectiles\n+        return [projectile]\n+\n+    def draw(self, screen: pygame.Surface, arena_height: float):\n+        \"\"\"\n+        Custom draw method for the weapon pickup: looks like a glowing energy orb/gauntlet.\n+        \"\"\"\n+        if self.is_equipped:\n+            return\n+\n+        # World (Y-up) to Screen (Y-down)\n+        py_y = arena_height - self.location[1] - self.height\n+        center_x = self.location[0] + self.width // 2\n+        center_y = py_y + self.height // 2\n+\n+        # Animated pulse effect\n+        pulse = (math.sin(time.time() * 5) + 1) / 2  # 0 to 1\n+        glow_radius = 15 + (10 * pulse)\n+        \n+        # Draw glow\n+        glow_surf = pygame.Surface((glow_radius * 2, glow_radius * 2), pygame.SRCALPHA)\n+        pygame.draw.circle(glow_surf, (100, 200, 255, 100), (int(glow_radius), int(glow_radius)), int(glow_radius))\n+        screen.blit(glow_surf, (center_x - glow_radius, center_y - glow_radius))\n+\n+        # Draw core orb\n+        pygame.draw.circle(screen, (255, 255, 255), (int(center_x), int(center_y)), 8)\n+        pygame.draw.circle(screen, (0, 150, 255), (int(center_x), int(center_y)), 10, 2)\n+\n+        # Draw name\n+        super().draw(screen, arena_height)"
    }
  ]
}